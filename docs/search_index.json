[["index.html", "统计计算 背景", " 统计计算 Huang 2021-08-16 背景 开始学习《统计计算》，主要参考李东风老师的网页教材，链接：https://www.math.pku.edu.cn/teachers/lidf/docs/statcomp/html/_statcompbook/index.html 。 2021-7-6 "],["intro-error.html", "1 误差 1.1 习题", " 1 误差 library(purrr) 1.1 习题 习题1 编程计算机器的值。 解： R语言中可以使用 .Machine$double.eps #&gt; [1] 2.22e-16 .Machine下面列有很多误差相关的机器参数，有需要的可以查阅这里。 习题2 设某正数\\(a\\)四舍五入后保留了\\(p\\)位有效数字，表示成\\(a^* = (0.a_1a_2\\cdots a_p)_{10}\\times10^m(a_1\\ne0)\\)。 估计其绝对误差和相对误差的范围， 并分析误差与有效数字位数\\(p\\)的关系。 解： 容易知道，\\(m\\ge p\\)。先通过一个例子直观理解一下，不妨取\\(a=12546\\)，当取\\(p=3\\)，有\\(a^*=0.125\\times 10^5=12500\\)，当取\\(p=4\\)，有\\(a^*=0.1255\\times 10^5=12550\\)。 所以可以得到，\\(m\\)实际上是正数\\(a\\)的位数，而\\(p\\)则是要保留的有效数字的位数。 其绝对误差： \\[ \\Delta = a-a^*\\le 0.5\\times10^{m-p} \\] 利用\\(a\\ge10^m\\)，其相对误差： \\[ \\delta = \\frac{\\Delta}{a} \\le\\frac{0.5\\times10^{m-p}}{10^m}=0.5\\times10^{-p} \\] 习题3 解： 先定义通项： myfun &lt;- function(n) { (-1)^(n+1)/n } n &lt;- 10^6 S &lt;- 0 for (i in 1:n) { S &lt;- S+myfun(i) } abs(S-log(2)) #&gt; [1] 5e-07 S &lt;- 0 for (i in 1:n) { S &lt;- S+myfun(n+1-i) } abs(S-log(2)) #&gt; [1] 5e-07 S &lt;- 0 l &lt;- vector(&quot;double&quot;,n/2) for (i in 1:(n/2)) { l[[i]] &lt;- myfun(2*i-1)+myfun(2*i) } for (i in l) { S &lt;- S+i } abs(S-log(2)) #&gt; [1] 5e-07 l &lt;- vector(&quot;double&quot;,n/2) for (i in 1:(n/2)) { l[[i]] &lt;- 1/(2*n*2*(n-1)) } for (i in l) { S &lt;- S+i } abs(S-log(2)) #&gt; [1] 3.75e-07 第4种方法精度更高。 习题4 解： x &lt;- 1:4 myfun1 &lt;- function(x, k=10) { S &lt;- 1 for (i in 1:k) { m &lt;- (-x)^i/factorial(i) S &lt;- S+m } S } myfun2 &lt;- function(x, k=10) { S &lt;- 1 for (i in 1:k) { m &lt;- x^i/factorial(i) S &lt;- S+m } 1/S } s1 &lt;- map_dbl(x,myfun1) s2 &lt;- map_dbl(x,myfun2) s &lt;- exp(-x) df &lt;- data.frame(x,s1=abs(s1-s),s2=abs(s2-s)) knitr::kable(df) x s1 s2 1 0.000 0 2 0.000 0 3 0.004 0 4 0.078 0 方法1的误差太大了，不妨增大\\(k\\)值： s1 &lt;- map_dbl(x,myfun1,k=100) s2 &lt;- map_dbl(x,myfun2) s &lt;- exp(-x) df &lt;- data.frame(x,s1=abs(s1-s),s2=abs(s2-s)) knitr::kable(df) x s1 s2 1 0 0 2 0 0 3 0 0 4 0 0 误差瞬间下去，说明方法1的收敛比较慢。以\\(x=4\\)为例，探究两个方法的收敛速度： x &lt;- 4 k &lt;- 1:50 s1 &lt;- map_dbl(k,myfun1,x=x) s2 &lt;- map_dbl(k,myfun2,x=x) s &lt;- exp(-x) opar &lt;- par(no.readonly = TRUE) plot(k,abs(s1-s),&quot;l&quot;,ylab=&quot;&quot;) lines(k,abs(s2-s),lty=2,col=&quot;red&quot;) title(ylab=&quot;绝对误差&quot;) legend(&quot;topright&quot;,c(&quot;公式（1）&quot;,&quot;公式（2）&quot;),lty=c(1,2),col=c(&quot;black&quot;,&quot;red&quot;)) par(opar) 可以看到公式（1）的收敛速度一开始是很慢的。 习题5 解： 载入数据： x &lt;- c(249, 254, 243, 268, 253, 269, 287, 241, 273, 306303, 280, 260, 256, 278, 344, 304, 283, 310) n &lt;- length(x) 公式1： s1 &lt;- 0 for (i in x) { s1 &lt;- signif(s1+signif(i^2,digits = 6),digits = 6) } s1 &lt;- signif(s1-n*mean(x),digits = 6) s1 &lt;- signif(s1/(n-1),digits = 6) 公式2： s2 &lt;- 0 m &lt;- mean(x) for (i in x) { s2 &lt;- signif(s2+signif((i-m)^2,digits = 6),digits = 6) } s2 &lt;- signif(s2/(n-1),digits = 6) 比较： df &lt;- data.frame(`函数直接计算`=var(x),`公式1`=s1,`公式2`=s2) knitr::kable(df) 函数直接计算 公式1 公式2 5.2e+09 5.52e+09 5.2e+09 公式2比公式1更精确，公式1先计算平方求和，值太大，保留6位有效数字之后损失较多。 习题6 解： "],["intro-summary.html", "2 概括统计量 2.1 习题", " 2 概括统计量 library(tidyverse) #&gt; -- Attaching packages ----- tidyverse 1.3.0 -- #&gt;  ggplot2 3.3.2  dplyr 1.0.2 #&gt;  tibble 3.0.3  stringr 1.4.0 #&gt;  tidyr 1.1.1  forcats 0.5.0 #&gt;  readr 1.3.1 #&gt; -- Conflicts -------- tidyverse_conflicts() -- #&gt; x dplyr::filter() masks stats::filter() #&gt; x dplyr::lag() masks stats::lag() 2.1 习题 习题1 解： skewness &lt;- function(x) { n &lt;- length(x) y &lt;- (x-mean(x))/sd(x) phi &lt;- n*sum(y^3)/(n-1)/(n-2) phi } 测试： x &lt;- c(8.75, 10.37, 8.33, 13.19, 10.66, 8.36, 10.97, 11.48, 11.15, 9.39) skewness(x) #&gt; [1] 0.3516643 习题2 解： 定义函数： quantile_est &lt;- function(x, p) { p &lt;- as.double(p) if(p&lt;0 | p&gt;1) stop(&quot;The &#39;p&#39; is out of [0,1].&quot;) else if(p==0) xp &lt;- min(x) else if(p==1) xp &lt;- max(x) else{ n &lt;- length(x) t &lt;- table(x) r &lt;- as.double(names(t)) i &lt;- floor(p*(n+1/3)+1/3) # xq左侧的x(i) j &lt;- i+t[names(t)==r[i]] # xq右侧x(j) k &lt;- (j-i)/(n+1/3)/(r[i+1]-r[i]) xp &lt;- p-(i-1/3)/(n+1/3)+k*r[i] xp &lt;- xp/k } names(xp) &lt;- p xp } 与quantile()以及真实分位数的比较： x &lt;- rnorm(1000) tbl &lt;- tibble(p = seq(0,1,by = 0.1)) tbl[&quot;real&quot;] &lt;- qnorm(tbl$p) tbl[&quot;quantile&quot;] &lt;- quantile(x,tbl$p) tbl[&quot;quantile_est&quot;] &lt;- map_dbl(tbl$p,quantile_est,x=x) tbl %&gt;% ggplot(aes(x=p))+ geom_line(aes(y=real,color=&quot;real&quot;))+ geom_line(aes(y=quantile,color=&quot;quantile&quot;))+ geom_line(aes(y=quantile_est,color=&quot;quantile_est&quot;),linetype=2)+ ylab(&quot;value&quot;) 可以看到，自定义函数跟quantile()函数得到的值重合度非常高，与真实分位数也差别不大。 习题3 解： 3.2.1 证明： \\[ \\bar{x}_n = \\frac1n\\sum_{i=1}^nx_i=\\frac{n-1}n\\times\\frac{\\sum_{i=1}^{n-1}x_i}{n-1}+\\frac{x_n}n=\\frac{n-1}n\\bar{x}_{n-1}+\\frac{x_n}n \\] 3.2.2 证明： \\[ \\begin{align} (n-1)S_n^2 &amp;= \\sum_{i=1}^n(x_i-\\bar x_n)^2\\\\ &amp;= \\sum_{i=1}^n(x_i-\\bar x_{n-1}+\\bar x_{n-1}-\\bar x_n)^2\\\\ &amp;= \\sum_{i=1}^n(x_i-\\bar x_{n-1})^2+2(\\bar x_{n-1}-\\bar x_n)\\sum_{i=1}^n(x_i-\\bar x_{n-1})+\\sum_{i=1}^n(\\bar x_{n-1}-\\bar x_n)^2\\\\ &amp;= (n-2)S_{n-1}^2+(x_n-\\bar x_{n-1})^2-2n(\\bar x_n-\\bar x_{n-1})^2+n(\\bar x_{n-1}-\\bar x_n)^2\\\\ &amp;= (n-2)S_{n-1}^2+(x_n-\\bar x_{n-1})^2-n(\\bar x_n-\\bar x_{n-1})^2\\\\ &amp;= (n-2)S_{n-1}^2+(x_n-\\bar x_{n-1})^2-n(\\frac{x_n}{n}-\\frac{\\bar x_{n-1}}{n})^2\\\\ &amp;= (n-2)S_{n-1}^2+(x_n-\\bar x_{n-1})^2-\\frac1n(x_n-\\bar x_{n-1})^2\\\\ &amp;= (n-2)S_{n-1}^2+\\frac{n-1}n(x_n-\\bar x_{n-1})^2 \\end{align} \\] 从而： \\[ S_n^2 = \\frac{n-2}{n-1}S_{n-1}^2+\\frac{1}n(x_n-\\bar x_{n-1})^2 \\] 习题4 解： 求均值的递推公式一样，直接向量化运算就行. 求协方差的递推算法跟求方差类似： 由于 \\[ \\Sigma_n = \\frac{1}{n-1}\\sum_{i=1}^n(x_i-\\bar x_n)(x_i-\\bar x_n)^T \\] 从而： \\[ \\begin{align} (n-1)\\Sigma_n &amp;= \\sum_{i=1}^n(x_i-\\bar x_n)(x_i-\\bar x_n)^T\\\\ &amp;= \\sum_{i=1}^n(x_i-\\bar x_{n-1}+\\bar x_{n-1}-\\bar x_n)(x_i-\\bar x_{n-1}-\\bar x_{n-1}+\\bar x_n)^T\\\\ &amp;= (n-2)\\Sigma_{n-1}+\\frac{n-1}{n}(x_n-\\bar x_{n-1})(x_n-\\bar x_{n-1})^T \\end{align} \\] 即 \\[ \\Sigma_n = \\frac{n-2}{n-1}\\Sigma_{n-1}+\\frac{1}{n}(x_n-\\bar x_{n-1})(x_n-\\bar x_{n-1})^T \\] "],["intro-graph.html", "3 统计图形 3.1 习题", " 3 统计图形 library(tidyverse) library(GGally) #&gt; Registered S3 method overwritten by &#39;GGally&#39;: #&gt; method from #&gt; +.gg ggplot2 set.seed(1024) 3.1 习题 习题1 解： opar &lt;- par(no.readonly = TRUE) par(mfrow=c(5,3)) par(mar=rep(2,4)) #第一种 n=c(10, 20, 30, 50, 100) for(i in seq_along(n)) { hist(rnorm(n[[i]]),freq = FALSE,main = paste(&quot;n=&quot;,n[[i]],&quot;，标准正态&quot;)) hist(exp(rnorm(n[[i]])),freq = FALSE,main = paste(&quot;n=&quot;,n[[i]],&quot;，对数正态&quot;)) hist(rcauchy(n[[i]]),freq = FALSE,main = paste(&quot;n=&quot;,n[[i]],&quot;，柯西分布&quot;)) } par(opar) 习题2 解： iris %&gt;% ggpairs(aes(color=Species,shape=Species), columns = 1:4, upper = list(continuous = &quot;points&quot;)) "],["rng-uniform.html", "4 均匀分布随机数生成 4.1 习题", " 4 均匀分布随机数生成 set.seed(1024) 4.1 习题 习题1 易证。 习题2 解： 将[0,1]等分为\\(k\\)段，每个端点分别为\\(x_i=i/k,i=0,\\dots,k\\)，考虑左闭右开区间，如果给定点\\(x\\)落在\\(x_i\\le x&lt;x_{i+1}\\)中，有\\(i/k\\le x&lt;(i+1)/k\\)，即\\(i\\le kx &lt;i+1\\)，\\(\\lfloor kx \\rfloor=i\\)，若\\(x&lt;0\\)或\\(x&gt;1\\)报错。 runif.chisq.test &lt;- function(x, k) { y &lt;- rep(0,k) for (i in seq_along(x)) { j &lt;- floor(k*x[[i]]) # 第j段 if(x[[i]]==1){ y[[k]] &lt;- y[[k]]+1 }else if(j&lt;0 | j&gt;=k){ stop(&quot;there is value of x out of [0,1]&quot;) }else{ y[[j+1]] &lt;- y[[j+1]]+1 } } chisq.test(y) } 测试一下： x &lt;- runif(1000) k &lt;- 10 runif.chisq.test(x,k) #&gt; #&gt; Chi-squared test for given probabilities #&gt; #&gt; data: y #&gt; X-squared = 3.06, df = 9, p-value = 0.9619 通过检验。 x &lt;- rnorm(1000) x &lt;- x[x&gt;=0&amp;x&lt;=1] k &lt;- 10 runif.chisq.test(x,k) #&gt; #&gt; Chi-squared test for given probabilities #&gt; #&gt; data: y #&gt; X-squared = 20.047, df = 9, p-value = 0.01763 显著性水平0.05下拒绝原假设。 习题3 解： 类似地，这里对输入数据的最小值与最大值之间等分\\(k\\)段，每个端点分别为\\(x_i=i/k,i=0,\\dots,k\\)，考虑左闭右开区间，如果给定点\\(x\\)落在\\(x_i\\le x&lt;x_{i+1}\\)中，有\\(i/k\\le x&lt;(i+1)/k\\)，即\\(i\\le kx &lt;i+1\\)，\\(\\lfloor kx \\rfloor=i\\)。 # F为分布函数 random.chisq.test &lt;- function(x, k, F) { library(purrr) xmin &lt;- min(x) xmax &lt;- max(x) d &lt;- xmax-xmin j &lt;- floor(k*(x-xmin)/d) y &lt;- rep(0,k+2) for (i in seq_along(x)) { if(x[[i]]==max(x)){ y[[k+1]] &lt;- y[[k+1]]+1 }else{ y[[j[[i]]+2]] &lt;- y[[j[[i]]+2]]+1 } } p &lt;- seq(xmin,xmax,length.out = k+1) %&gt;% map_dbl(F) p &lt;- c(p[[1]],diff(p),1-p[[k+1]]) chisq.test(y,p = p) } 测试： x &lt;- rnorm(1000) k &lt;- 10 random.chisq.test(x,k,pnorm) #&gt; Warning in chisq.test(y, p = p): Chi-squared approximation may be incorrect #&gt; #&gt; Chi-squared test for given probabilities #&gt; #&gt; data: y #&gt; X-squared = 8.422, df = 11, p-value = 0.6751 x &lt;- runif(1000) k &lt;- 10 random.chisq.test(x,k,pnorm) #&gt; #&gt; Chi-squared test for given probabilities #&gt; #&gt; data: y #&gt; X-squared = 2044.9, df = 11, p-value &lt; 2.2e-16 通过测试。 习题4 解： 这个应该是下一节的内容，不过无所谓啦。先得到它的分布函数为 \\[ F(x) = \\frac12x+\\frac12x^2,\\quad0\\le x\\le1 \\] 1、逆变换法： 先求\\(F^{-1}\\)为： \\[ F^{-1}(u) = -\\frac12+\\sqrt{2u+\\frac14} \\] 从而定义函数： rng.x1 &lt;- function(n) { -0.5+sqrt(2*runif(n)+0.25) } 测试： n &lt;- 1000 x &lt;- rng.x1(n) hist(x,freq = FALSE) y &lt;- seq(0,1,0.01) z &lt;- 0.5+y lines(y,z,col=&quot;red&quot;) 基本吻合。 2、舍选法 就是拒绝采样啦，取提议分布为均匀分布\\(U[0,1]\\)，则\\(c=1.5\\). rng.x2 &lt;- function(n) { x &lt;- runif(n) y &lt;- runif(n,0,1.5) s &lt;- x[y&lt;=0.5+x] list(samples = s, eff = length(s)/n) } 测试： n &lt;- 1000 x &lt;- rng.x2(n) hist(x$samples,freq = FALSE) y &lt;- seq(0,1,0.01) z &lt;- 0.5+y lines(y,z,col=&quot;red&quot;) 基本吻合。看一下效率： x$eff #&gt; [1] 0.669 理论上的效率为\\(2/3\\)。 3、复合法 将梯形面积分解为一个矩形跟一个三角形，两者面积都是0.5。 rng.x3 &lt;- function(n) { i &lt;- runif(n) x &lt;- runif(n) # 小于等于0.5保持值，大于0.5开平方 x[i&gt;0.5] &lt;- sqrt(x[i&gt;0.5]) x } 测试： n &lt;- 1000 x &lt;- rng.x3(n) hist(x,freq = FALSE) y &lt;- seq(0,1,0.01) z &lt;- 0.5+y lines(y,z,col=&quot;red&quot;) 比较算法的效率？除了舍选法会拒绝点之外，其余两者算法都是全部接受点的。看一下函数的运行时间吧，虽然这个比较粗糙，因为跟算法编码的设计有关，不一定是算法本身的问题： n &lt;- 10000000 t1.1 &lt;- proc.time() x &lt;- rng.x1(n) t1.2 &lt;- proc.time() t1 &lt;- t1.2-t1.1 t2.1 &lt;- proc.time() x &lt;- rng.x2(n) t2.2 &lt;- proc.time() t2 &lt;- t2.2-t2.1 t3.1 &lt;- proc.time() x &lt;- rng.x3(n) t3.2 &lt;- proc.time() t3 &lt;- t3.2-t3.1 df &lt;- data.frame(`逆变换法`=t1[3][[1]],`舍选法`=t2[3][[1]],`复合法`=t3[3][[1]]) knitr::kable(df) 逆变换法 舍选法 复合法 0.52 1.06 1.1 总的来说，逆变换法要更好点，舍选法要稍差点。 "],["rng-nonuni.html", "5 非均匀随机数生成 5.1 笔记 5.2 习题", " 5 非均匀随机数生成 library(tidyverse) 5.1 笔记 5.1.1 用逆变换法生成离散型随机数 定理6.2非常重要，主要的思路就是明确概率空间点集，然后求在点集上各点的分布函数值（累加），再生成[0,1]均匀分布随机数，找到对应分布函数值大于等于它并最与它接近的点值，就是服从给定分布的一个随机数。书本上一开始定义是对应分布函数值大于等于它并最与它接近的点值，后来代码又变成了对应分布函数值小于于等于它并最与它接近的点值，有点莫名其妙。 5.1.2 R中的离散分布函数 看一下对于离散分布，R中的分布函数定义是\\(P\\{X\\le x\\}\\)还是\\(P\\{X&lt; x\\}\\)。考虑\\(b(3,0.5)\\)， pbinom(1,3,0.5) #&gt; [1] 0.5 也即是\\(F(1)=0.5\\).由于\\(P\\{X\\le 1\\}=P\\{X= 0,1\\}=0.5\\)，所以在R中分布函数的定义为\\(F(x)=P\\{X\\le x\\}\\). 5.2 习题 习题1 解： 先定义一个函数： myfun &lt;- function(n) { x &lt;- rep(2,n) i &lt;- runif(n) j &lt;- i&lt;1/3 x[j] &lt;- 1 list(samples = x, p = mean(j)) } n &lt;- c(100,1000,10000) p &lt;- n %&gt;% map(myfun) %&gt;% map_dbl(~.$p) knitr::kable(data.frame(n=n,p=p),align = &quot;cc&quot;) n p 100 0.3300 1000 0.3230 10000 0.3377 第4问不太看得懂，先占坑。 习题2 解： 仿照例6.2： rng.pk &lt;- function(n, pk) { if(sum(pk)!=1) stop(&quot;the sum of pk must be 1&quot;) m &lt;- length(pk) Fvs &lt;- c(0,cumsum(pk[-m])) p &lt;- runif(n) x &lt;- vector(&quot;integer&quot;,n) for (i in seq_along(x)) { j &lt;- max(which(Fvs &lt;= p[[i]])) x[i] &lt;- j } x } 测试： x &lt;- rng.pk(1000,c(0.1,0.3,0.6)) prop.table(table(x))*100 #&gt; x #&gt; 1 2 3 #&gt; 10.3 31.4 58.3 习题3 解： 先进行统计模拟。 # n次实验 draw.card &lt;- function(n) { x &lt;- vector(&quot;double&quot;,n) for (i in seq_along(x)) { s &lt;- sample(1:54,replace = FALSE) # 1次实验结果 x[[i]] &lt;- sum(s==(1:54)) } x } # 取n=100000 n &lt;- 100000 x &lt;- draw.card(n) sum(x==0) #&gt; [1] 36806 mean(x) #&gt; [1] 0.99936 var(x) #&gt; [1] 0.9978296 均值跟方差都是1. 再进行理论推导。 容易知道，\\(T\\in\\{1,2,\\cdots,54\\}\\)为离散随机变量，需要用到全错位排列，不妨设\\(D_n\\)为总数为\\(n\\)的全错位排列数，有递推公式\\(D_n=(n-1)(D_{n-1}+D_{n-2})\\)，不妨补充定义\\(D_0=1\\)，则 \\[ P\\{T_n=0\\} = C_n^0\\cdot D_n/n!\\\\ P\\{T_n=1\\} = C_n^1\\cdot D_{n-1}/n!\\\\ \\cdots \\\\ P\\{T_n=k\\} = C_n^k\\cdot D_{n-k}/n!\\\\ \\cdots \\\\ P\\{T_n=n-1\\} = C_n^{n-1}\\cdot D_{1}/n!\\\\ P\\{T_n=n\\} = C_n^{n}\\cdot D_{0}/n!\\\\ \\] 题中当\\(n=54\\)，还是得借助计算机： # 先定义函数求[D_0,...,D_n] D.n &lt;- function(n) { D &lt;- vector(&quot;integer&quot;, n+1) for (i in seq_along(D)) { if(i==1) D[[i]] &lt;- 1 # D_0 else if(i==2) D[[i]] &lt;- 0 # D_1 else{ D[[i]] &lt;- (i-2)*(D[[i-1]]+D[[i-2]]) # D_{i-1} } } D } n &lt;- 54 i &lt;- n:0 P &lt;- D.n(n)*choose(n,i)/factorial(n) # P{T=n,...,0} # 求均值 m &lt;- sum(i*P) # 求方差 v &lt;- sum((i-m)^2*P) print(paste(&quot;均值=&quot;,m,&quot;,方差=&quot;,v,sep=&quot;&quot;)) #&gt; [1] &quot;均值=0.999999999999983,方差=0.999999999999983&quot; 考虑到误差，可以认为理论值的均值跟方差都是1. 习题4 解： 先定义投掷色子的函数： # 返回n次实验的结果 roll.dice &lt;- function(n) { x &lt;- rep(0, n) for (j in seq_along(x)) { l &lt;- rep(0,11) while (min(l)==0) { i &lt;- sum(sample.int(6, size=2, replace=TRUE)) # 投掷两次色子 l[[i-1]] &lt;- l[[i-1]]+1 x[[j]] &lt;- x[[j]]+1 } } x } # 开始模拟 n &lt;- 100000 x &lt;- roll.dice(n) mean(x) #&gt; [1] 61.1509 var(x) #&gt; [1] 1283.881 习题7 解： 这里需要注意的是，负二项分布的定义主要有两种，一种如题所示，另一种是独立重复试验中第\\(r\\)次成功所经历的失败次数（R函数的定义）。此外，关于几何分布也一样，R函数的定义是描述了独立重复试验中首次成功所经历的失败次数。 1、考虑几何分布跟负二项分布的关系。几何分布描述了独立重复试验中首次成功所需的试验次数，而负二项分布描述了独立重复试验中第\\(r\\)次成功所需的试验次数，则可以产生\\(r\\)个几何分布随机数，求和就是一个负二项分布随机数： rng.nbinom.1 &lt;- function(n, p, r) { y &lt;- matrix(rgeom(n*r,p)+1,n,r) # n行r列 x &lt;- apply(y, 1, sum) x } # 测试 n &lt;- 1000 p &lt;- 0.3 r &lt;- 3 x &lt;- rng.nbinom.1(n,p,r) y &lt;- 0:50 # 失败次数 yy &lt;- dnbinom(y,size = r,prob = p) hist(x,breaks=15,freq=FALSE) lines(y+r,yy,col=&quot;red&quot;) 2、直接利用负二项分布的概率分布，由于负二项分布： \\[ P\\{x=k\\} = \\binom{k-1}{r-1}p^r(1-p)^{k-r},\\quad k=r,r+1,\\cdots \\] 考虑分布函数： \\[ \\begin{align} F(k) &amp;= P\\{x\\le k\\}= P\\{\\text{在前k次实验至少成功r次}\\}\\\\ &amp;= 1-P\\{\\text{在前k次实验成功小于r次}\\}\\\\ &amp;= 1-\\sum_{i=0}^{r-1}P\\{\\text{在前k次实验成功i次}\\}\\\\ &amp;= 1-\\sum_{i=0}^{r-1}\\binom{k}{i}p^i(1-p)^{k-i}\\\\ &amp;:= 1-BS(k,r,p) \\quad k=r,r+1,\\cdots \\end{align} \\] 所以生成随机数\\(X\\)的方法为当且仅当\\(F(k-1)&lt; U\\le F(k)\\)取\\(X=k\\)。这又等价于 \\[ BS(k,r,p)\\le U &lt;BS(k-1,r,p) \\] 取 \\[ \\begin{align} X &amp;= \\min\\{k:BS(k,r,p)\\le U\\} \\end{align} \\] 定义函数： rng.nbinom.2 &lt;- function(n, p, r) { # 先定义BS函数 BS &lt;- function(k.,r.,p.) { i &lt;- 0:(r.-1) sum(choose(k.,i)*p.^i*(1-p.)^(k.-i)) } x &lt;- vector(&quot;integer&quot;, n) u &lt;- runif(n) for (j in seq_along(x)) { k &lt;- r # 初值 while (BS(k,r,p)&gt;u[[j]]) { k &lt;- k+1 } x[[j]] &lt;- k } x } # 测试 n &lt;- 1000 p &lt;- 0.3 r &lt;- 3 x &lt;- rng.nbinom.2(n,p,r) y &lt;- 0:50 # 失败次数 yy &lt;- dnbinom(y,size = r,prob = p) hist(x,breaks=15,freq=FALSE) lines(y+r,yy,col=&quot;red&quot;) 习题8 解： 1、先求分布函数的反函数： \\[ F^{-1}(u) = u^n \\] # m:随机数序列长度 # n:参数n rng.beta.1 &lt;- function(m, n) { u &lt;- runif(m) x &lt;- u^n x } # 测试 n &lt;- c(1,2,3,4) m &lt;- 1000 y &lt;- seq(0,1,0.01) opar &lt;- par(no.readonly = TRUE) par(mfrow=c(2,2)) for (i in seq_along(n)) { x &lt;- rng.beta.1(m, n[[i]]) hist(x,freq = FALSE,main=paste(&quot;n=&quot;,n[[i]],sep = &quot;&quot;)) lines(y,dbeta(y,1/n[[i]],1),col=&quot;red&quot;) } par(opar) 2、先求分布函数的反函数： \\[ F^{-1}(u) = u^{1/n} \\] # m:随机数序列长度 # n:参数n rng.beta.2 &lt;- function(m, n) { u &lt;- runif(m) x &lt;- u^{1/n} x } # 测试 n &lt;- c(1,2,3,4) m &lt;- 1000 y &lt;- seq(0,1,0.01) opar &lt;- par(no.readonly = TRUE) par(mfrow=c(2,2)) for (i in seq_along(n)) { x &lt;- rng.beta.2(m, n[[i]]) hist(x,freq = FALSE,main=paste(&quot;n=&quot;,n[[i]],sep = &quot;&quot;)) lines(y,dbeta(y,n[[i]],1),col=&quot;red&quot;) } par(opar) 3、先求分布函数的反函数： \\[ F^{-1}(u) = \\sin(\\frac{\\pi u}{2}) \\] rng.sin &lt;- function(n) { u &lt;- runif(n) sin(pi*u/2) } # 测试 n &lt;- 1000 x &lt;- rng.sin(n) hist(x,freq = FALSE) curve(2/(pi*sqrt(1-x^2)),0,1,add = TRUE,col=&quot;red&quot;) 4、先求分布函数的反函数： \\[ F^{-1}(u) = \\tan(\\pi u) \\] rng.tan &lt;- function(n) { u &lt;- runif(n) tan(pi*u) } # 测试 n &lt;- 1000 x &lt;- rng.tan(n) hist(x,freq = FALSE,breaks = 1000,xlim=c(-50,50),ylim=c(0,0.3)) curve(1/(pi*(1+x^2)),-50,50,add = TRUE,col=&quot;red&quot;) 5、先求分布函数的反函数： \\[ F^{-1}(u) = \\arcsin(u) \\] rng.asin &lt;- function(n) { u &lt;- runif(n) asin(u) } # 测试 n &lt;- 1000 x &lt;- rng.asin(n) hist(x,freq = FALSE) curve(cos(x),0,pi/2,add = TRUE,col=&quot;red&quot;) 6、先求分布函数的反函数： \\[ F^{-1}(u) = [-\\eta\\log(1-u)]^{1/\\alpha} \\] rng.weibull &lt;- function(n, alpha, eta) { u &lt;- runif(n) (-eta*log(1-u))^(1/alpha) } # 测试 alpha &lt;- c(0.5,1,1.5,2) eta &lt;- c(0.5,1,1.5,2) opar &lt;- par(no.readonly = TRUE) par(mfrow=c(2,2)) # 固定alpha=1 for (i in seq_along(eta)) { x &lt;- rng.weibull(n, alpha[[2]], eta[[i]]) hist(x,freq = FALSE,ylim=c(0,1.5),main = paste(&quot;alpha=1,eta=&quot;,eta[[i]],sep = &quot;&quot;)) curve(alpha[[2]]/eta[[i]]*x^(alpha[[2]]-1)*exp(-x^alpha[[2]]/eta[[i]]),0,5,add = TRUE,col=&quot;red&quot;) } # 固定eta=1 for (i in seq_along(alpha)) { x &lt;- rng.weibull(n, alpha[[i]], eta[[2]]) hist(x,freq = FALSE,main = paste(&quot;eta=1,alpha=&quot;,alpha[[i]],sep = &quot;&quot;)) curve(alpha[[i]]/eta[[2]]*x^(alpha[[i]]-1)*exp(-x^alpha[[i]]/eta[[2]]),0,20,add = TRUE,col=&quot;red&quot;) } par(opar) 习题9 解： 思路是循环批量生成\\(\\exp(1)\\)样本，再判断是否符合要求。关于每次生成样本数的选择，为了期望能循环一次就能得到\\(n\\)个符合要求的样本，可以利用\\(F(0.05)\\)作为批量生成样本中符合要求样本的概率，批量生成样本数可以大致利用\\(n/F(0.05)\\)。 rng.exp &lt;- function(n, x0=0.05) { x &lt;- vector(&quot;double&quot;, n) i &lt;- 0 # 记录符合要求的样本数 while (TRUE) { y &lt;- rexp(floor(n/pexp(x0))) # 分块生成样本，而不是单个生成 idx &lt;- (y&lt;x0) j &lt;- i+sum(idx) # 累计符合要求样本数 if(j&gt;=n){ x[(i+1):n] &lt;- y[idx][1:(n-i)] break() } else if(j==i) next() else{ x[(i+1):j] &lt;- y[idx] } i &lt;- j } x } # 随机模拟 n &lt;- 1000 x &lt;- rng.exp(n) m &lt;- mean(x) 模拟得到的均值约为0.0249387。 下面进行理论推导。直接利用： \\[ E(x)=\\int_0^{0.05}xp(x)\\mathrm dx = \\frac{1-1.05e^{-0.05}}{1-e^{-0.05}} \\] m1 &lt;- (1-1.05*exp(-0.05))/(1-exp(-0.05)) 利用计算机计算得到结果为0.0247917，相差1.4707064^{-4}。 习题10 解： 方法1：逆变换法，仿照例6.2 rng.10.1 &lt;- function(n, m, lambda) { i &lt;- 0:m prob &lt;- exp(-lambda)*lambda^i/factorial(i) # 排序 ord &lt;- order(prob, decreasing = TRUE) i &lt;- i[ord] prob &lt;- prob[ord] Fvs &lt;- c(0, cumsum(prob[1:m])) u &lt;- runif(n) x &lt;- vector(&quot;integer&quot;,n) for (j in 1:n) { x[j] &lt;- i[[max(which(Fvs &lt;= u[[j]]))]] } x } 方法2：注意到\\(P\\{X=k\\}=e^{-\\lambda}\\frac{\\lambda^k}{k!},k=0,1,\\cdots\\)，则\\(X\\)服从泊松分布。故可以生成服从泊松分布的随机数，若小于等于\\(m\\)则保留，否则丢弃，仿照习题9： rng.10.2 &lt;- function(n, m, lambda) { x &lt;- vector(&quot;double&quot;, n) i &lt;- 0 # 记录符合要求的样本数 while (TRUE) { y &lt;- rpois(floor(n/ppois(m,lambda)),lambda) # 分块生成样本，而不是单个生成 idx &lt;- (y&lt;=m) j &lt;- i+sum(idx) # 累计符合要求样本数 if(j&gt;=n){ x[(i+1):n] &lt;- y[idx][1:(n-i)] break() } else if(j==i) next() else{ x[(i+1):j] &lt;- y[idx] } i &lt;- j } x } 测试： # 测试 opar &lt;- par(no.readonly = TRUE) par(mfrow=c(1,2)) n &lt;- 1000 m &lt;- 10 lambda &lt;- 4 x &lt;- rng.10.1(n,m,lambda) y &lt;- rng.10.2(n,m,lambda) hist(x,freq=FALSE,breaks = m+1,ylim=c(0,0.25)) hist(y,freq=FALSE,breaks = m+1,ylim=c(0,0.25)) par(opar) 算是大致一致吧。 习题11 解： 1、逆变换法： 利用条件概率公式，设二项分布的分布函数为\\(F_1\\)： \\[ F(y) = P\\{Y\\le y\\}=\\frac{P\\{k\\le X\\le y\\}}{P\\{X\\ge k\\}}=\\frac{F_1(y)-F_1(k-1)}{1-F_1(k-1)},\\quad y=k,k+1,\\cdots,n \\] 则当 \\[ \\frac{F_1(i-1)-F_1(k-1)}{1-F_1(k-1)}&lt;u\\le \\frac{F_1(i)-F_1(k-1)}{1-F_1(k-1)},\\quad i=k,k+1,\\cdots,n \\] 时取\\(y=i\\)，上述条件又等价于 \\[ F_1(i-1)&lt;(1-F_1(k-1))u+F_1(k-1)\\le F_1(i) \\] 定义函数 # n:输出随机数长度 # size：实验次数 # k：题中参数 rng.11.1 &lt;- function(n, size, k=0, prob=0.5) { x &lt;- vector(&quot;integer&quot;, n) ss &lt;- k:size # 样本空间 Fvs &lt;- pbinom(ss,size,prob) # F_1值 u &lt;- runif(n) u &lt;- u+(1-u)*pbinom(k-1,size,prob) for (i in 1:n) { j &lt;- min(which(Fvs&gt;=u[[i]])) x[[i]] &lt;- ss[[j]] } x } 2、舍选法 密度函数： \\[ P\\{Y=y\\} = F(y)-F(y-1)=\\frac{F_1(y)-F_1(y-1)}{1-F_1(k-1)}=\\frac{P\\{X=y\\}}{1-F_1(k-1)},\\quad y=k,k+1,\\cdots,n \\] # 这里的n表示试投次数 rng.11.2 &lt;- function(n, size, k=0, prob=0.5) { y &lt;- k:size fvs &lt;- dbinom(y,size,prob)/(1-pbinom(k-1,size,prob)) x &lt;- sample(y,n,replace = TRUE) if(k==size){ x &lt;- rep(y, n) fvs &lt;- rep(1, 1) } u &lt;- runif(n,0,min(1,max(fvs))) for (i in seq_along(x)) { if(u[[i]]&gt;fvs[[x[[i]]-k+1]]) x[[i]] &lt;- -1 # 拒绝 } x[x&gt;-1] } 3、理论分析 由于 \\[ P\\{Y=y\\} = F(y)-F(y-1)=\\frac{F_1(y)-F_1(y-1)}{1-F_1(k-1)}=\\frac{P\\{X=y\\}}{1-F_1(k-1)},\\quad y=k,k+1,\\cdots,n \\] 有： # 测试 size &lt;- 10 k &lt;- 3 prob &lt;- 0.5 y &lt;- k:size p &lt;- dbinom(y,size,prob)/(1-pbinom(k-1,size,prob)) # 变换法 n &lt;- 10000 x &lt;- rng.11.1(n,size,k,prob) m1 &lt;- table(x)/n # 拒绝采样 n &lt;- 20000 x &lt;- rng.11.2(n,size,k,prob) m2 &lt;- table(x)/length(x) r &lt;- length(x)/n # 比较结果 df &lt;- data.frame(y=y,p=p,m1=as.double(m1),m2=as.double(m2)) knitr::kable(df,digits = 3) y p m1 m2 3 0.124 0.123 0.125 4 0.217 0.208 0.211 5 0.260 0.264 0.266 6 0.217 0.220 0.211 7 0.124 0.126 0.124 8 0.046 0.048 0.052 9 0.010 0.010 0.010 10 0.001 0.001 0.000 基本上相差不大。 接下来考虑\\(\\alpha=P\\{X\\ge k\\}\\)对拒绝采样接受率的影响，实验中取不同的\\(k\\)用于表示不同的\\(\\alpha\\)。 size &lt;- 20 k &lt;- 0:size prob &lt;- 0.4 n &lt;- 20000 # 试投点数 r &lt;- vector(&quot;double&quot;,length(k)) for(i in seq_along(k)){ x &lt;- rng.11.2(n,size,k[[i]],prob) r[[i]] &lt;- length(x)/n # 接受率 } alpha &lt;- 1-pbinom(k-1,size,prob) plot(alpha,r,type=&quot;p&quot;,pch=16,cex=0.5,col=&quot;blue&quot;) 也不好说\\(\\alpha\\)取什么值时拒绝采样方法不可取，应该是比较小的时候。 习题12 解： 方法1：拒绝采样 先观察一下密度函数： curve(x*exp(-x),0,20,ylab=&quot;p(x)&quot;) 若使用均匀分布作提议分布，容易求得 \\[ \\min p(x) = p(1) = 1/e \\] 采样： # 提议分布为均匀分布 # px为密度函数, # n不是生成px的样本数，而是提议分布的样本数 rejection_sampling_unit &lt;- function(px, n, c,...){ x &lt;- runif(n, ...) # 生成n个随机数 y &lt;- px(x) z &lt;- runif(n, 0, c) d &lt;- (z&lt;=y) output &lt;- list(data = tibble(x,y,z,d), samples = x[d]) return(output) } px &lt;- function(x){ y &lt;- ifelse(x&gt;0,x*exp(-x),0) } n &lt;- 10000 c = 1/exp(1) out1 &lt;- rejection_sampling_unit(px, n, c, 0, 10) tb1 &lt;- out1$data tb1 %&gt;% ggplot(mapping = aes(x = x)) + geom_point(mapping = aes(y = z, color = d, shape=d), size = 0.5) + geom_line(aes(y = y)) + geom_line(aes(y = c), linetype = 7)+ labs(x=&quot;z&quot;,y=NULL,color=&quot;acceptance&quot;,shape = &quot;acceptance&quot;)+ scale_shape_manual(values = c(20,8))+ ggtitle(paste(&quot;以均匀分布作提议分布的拒绝采样，接受率=&quot;,mean(tb1$d),sep = &quot;&quot;)) 接受率比较低，效率不高。 方法2：利用指数分布作提议分布。注意到\\(X\\sim\\mathrm{Gamma}(2,1)\\)，\\(EX=2\\)，使用期望为\\(1\\)的指数分布\\(g(x)=0.5e^{-0.5x}\\)作为提议分布。 # 提议分布为均匀分布 # px为密度函数, # n不是生成px的样本数，而是提议分布的样本数 rejection_sampling_exp &lt;- function(px, n,...){ x &lt;- rexp(n, ...) # 生成n个随机数 y &lt;- px(x) gx &lt;- dexp(x, ...) ppx &lt;- max(y/gx)*gx # 求c z &lt;- runif(n, 0, ppx) d &lt;- (z&lt;=y) output &lt;- list(data = tibble(x,y,z,d,ppx), samples = x[d]) return(output) } px &lt;- function(x){ y &lt;- ifelse(x&gt;0,x*exp(-x),0) } n &lt;- 5000 out1 &lt;- rejection_sampling_exp(px, n, 0.5) tb1 &lt;- out1$data tb1 %&gt;% ggplot(mapping = aes(x = x)) + geom_point(mapping = aes(y = z, color = d, shape=d), size = 0.5) + geom_line(aes(y = y)) + geom_line(aes(y = ppx), linetype = 7)+ labs(x=&quot;z&quot;,y=NULL,color=&quot;acceptance&quot;,shape = &quot;acceptance&quot;)+ scale_shape_manual(values = c(20,8))+ ggtitle(paste(&quot;以指数分布作提议分布的拒绝采样，接受率=&quot;,mean(tb1$d),sep = &quot;&quot;)) 接受率提高了很多。 习题13 解： 设 \\[ P\\{Z=1\\}=0.3,P\\{Z=2\\}=0.3,P\\{Z=3\\}=0.26,P\\{Z=4\\}=0.14 \\] 当\\(Z=1\\)，X均匀取\\(1,2,3,4,5\\)，当\\(Z=2\\)，X均匀取\\(6,9\\)，当\\(Z=3\\)，X均匀取\\(7,10\\)，当\\(Z=4\\)，X均匀取\\(8\\). rng.13 &lt;- function(n) { z &lt;- sample.int(4, n, replace = TRUE, prob = c(0.3,0.3,0.26,0.14)) x &lt;- vector(&quot;integer&quot;,n) x[z==1] &lt;- sample(1:5,sum(z==1),replace = TRUE) x[z==2] &lt;- sample(c(6,9),sum(z==2),replace = TRUE) x[z==3] &lt;- sample(c(7,10),sum(z==3),replace = TRUE) x[z==4] &lt;- 8 x } # 测试 n &lt;- 10000 x &lt;- rng.13(n) table(x)/n #&gt; x #&gt; 1 2 3 4 5 6 7 8 9 10 #&gt; 0.0613 0.0590 0.0602 0.0585 0.0589 0.1507 0.1245 0.1407 0.1510 0.1352 大致符合。 习题14 解： 似乎有点问题。 \\[ F(k)=P\\{X\\le k\\}=\\sum_{i=1}^kP\\{X=i\\}=\\frac32-\\frac{1}{2^{k+1}}-\\frac{2^k}{3^k}\\rightarrow \\frac32\\ne 1 \\] 习题15 解： 1、逆变换法： 先求分布函数： \\[ F(x)= \\begin{cases} \\frac12 e^x &amp; x\\le 0\\\\ 1-\\frac12 e^{-x} &amp; x&gt;0\\\\ \\end{cases} \\] 求逆函数可以得到： \\[ X= \\begin{cases} \\log(2u) &amp; u\\le 0.5\\\\ -\\log(2(1-u)) &amp; u&gt;0.5 \\end{cases} \\] 采样函数： rng.15.1 &lt;- function(n) { u &lt;- runif(n) x &lt;- ifelse(u&lt;=0.5,log(2*u),-log(2-2*u)) x } # 测试 n &lt;- 10000 x &lt;- rng.15.1(n) hist(x,breaks = 100,freq = FALSE,ylim=c(0,0.5)) curve(0.5*exp(-abs(x)),from = -10,to =10,add = TRUE,col=&quot;red&quot;) 2、复合法 实际上类似于上面的逆变换法，设 \\[ P\\{Z=0\\}=P\\{Z=1\\}=0.5 \\] 当\\(Z=0\\)，取\\(X=\\log u\\)，当\\(Z=1\\)，取\\(X=-\\log u\\)。 采样函数： rng.15.2 &lt;- function(n) { z &lt;- runif(n) u &lt;- runif(n) x &lt;- log(u) x &lt;- ifelse(z&lt;=0.5,x,-x) x } # 测试 n &lt;- 10000 x &lt;- rng.15.2(n) hist(x,breaks = 100,freq = FALSE,ylim=c(0,0.5)) curve(0.5*exp(-abs(x)),from = -10,to =10,add = TRUE,col=&quot;red&quot;) 习题16 解： 比较容易想到的当然是拒绝采样。 先观察密度函数形状： curve(x*(1-x)^3/0.000336,0.8,1,ylab=&quot;p(x)&quot;) 使用均匀分布作提议分布拒绝率应该会在0.5以下，不妨考虑一下\\([0.8,1]\\)上的三角分布： \\[ p(x) = 50-50x,\\qquad 0.8&lt;x&lt;1 \\] 其分布函数的逆为： \\[ F^{-1}(u) = 1-\\frac{\\sqrt{u}}{5} \\] # 提议分布为三角分布 # px为密度函数, # n不是生成px的样本数，而是提议分布的样本数 rejection_sampling_tri &lt;- function(px, n){ x &lt;- 1-sqrt(runif(n))/5 # 生成n个随机数 y &lt;-px(x) # 提议分布 ppx &lt;- (px(1)-px(0.8))/0.2*(x-0.8)+px(0.8) z &lt;- runif(n,0,ppx) d &lt;- (z&lt;=y) output &lt;- list(data = tibble(x,y,ppx,z,d), samples = x[d]) return(output) } px &lt;- function(x){ x*(1-x)^3/0.000336 } n &lt;- 10000 out1 &lt;- rejection_sampling_tri(px, n) tb1 &lt;- out1$data tb1 %&gt;% ggplot(mapping = aes(x = x)) + geom_point(mapping = aes(y = z, color = d, shape=d), size = 0.5) + geom_line(aes(y = y)) + geom_line(aes(y = ppx), linetype = 7)+ labs(x=&quot;z&quot;,y=NULL,color=&quot;acceptance&quot;,shape = &quot;acceptance&quot;)+ scale_shape_manual(values = c(20,8))+ ggtitle(paste(&quot;以三角分布作提议分布的拒绝采样，接受率=&quot;,mean(tb1$d),sep = &quot;&quot;)) 还有另一个方法是，注意到这是一个条件\\(\\mathrm{Beta}(2,4)\\)分布，即 \\[ p(x) = p(y|y&gt;0.8),\\quad y\\sim \\mathrm{Beta}(2,4) \\] 所以另一个办法就是生成\\(\\mathrm{Beta}(2,4)\\)分布随机数，若大于\\(0.8\\)就保留： # n：试投点数 rng.16.2 &lt;- function(n) { x &lt;- rbeta(n,2,4) x[x&gt;0.8] } # 测试 n &lt;- 100000 x &lt;- rng.16.2(n) hist(x,freq = FALSE) curve(x*(1-x)^3/0.000336,0.8,1,add = TRUE,col=&quot;red&quot;) length(x)/n #&gt; [1] 0.00635 但是拒绝率太低了，惨不忍睹。 习题17 解： 只证前半部分。 把\\(Y\\)看作\\(X\\)的一个变换，\\(Y=g(X)=a+(b-a)X\\)，\\(X\\)有密度函数\\(p_R(x)=2x,x\\in(0,1)\\)，函数\\(g(\\cdot)\\)有反函数\\(x=g^{-1}(y)=h(y)=(y-a)/(b-a)\\)，则\\(Y\\)有密度函数： \\[ p_Y(x) = p_R(h(y))\\cdot|h&#39;(y)|=2\\cdot\\frac{y-a}{b-a}\\cdot\\frac1{b-a}=\\frac{2(y-a)}{(b-a)^2},\\quad y\\in(a,b) \\] 故\\(Y\\sim\\mathrm{RT}(a,b)\\). 类似地，令\\(Y=g(X)=1-X\\)，\\(h(y)=1-y\\)，则\\(Y\\)有密度函数 \\[ p_Y(x) = p_R(h(y))\\cdot|h&#39;(y)|=2(1-y)\\cdot|-1|=2(1-y),\\quad y\\in(0,1) \\] 故\\(Y\\sim\\mathrm{LT}(0,1)\\). \\(X\\)的分布函数 \\[ F(x)=P\\{X\\le x\\}=P\\{U_1\\le x,U_2\\le x\\}=P\\{U_1\\le x\\}P\\{U_2\\le x\\}=x^2,\\quad x\\in (0,1) \\] 故\\(X\\sim\\mathrm{RT}(0,1)\\). 习题18 解： 只需要证明它是变形的Box-Muller变换即可。 由于\\(\\alpha\\sim U(0,1)\\)，则\\(\\tilde\\alpha=\\alpha/2\\pi\\sim U(0,1)\\). 由于\\(R\\sim\\exp(1/2)\\)，则\\(1-e^{-R/2}\\sim U(0,1)\\)，即\\(\\tilde R=e^{-R/2}\\sim U(0,1)\\). 并且还有\\(\\alpha\\perp\\!\\!\\!\\!\\perp R\\)，所以\\(\\tilde\\alpha\\perp\\!\\!\\!\\!\\perp \\tilde R\\)，利用Box-Muller公式，有 \\[ \\begin{cases} X = \\sqrt{-2\\ln\\tilde R}\\cos\\left(\\frac{\\alpha}{2\\pi}\\cdot 2\\pi\\right)\\\\ Y = \\sqrt{-2\\ln\\tilde R}\\sin\\left(\\frac{\\alpha}{2\\pi}\\cdot 2\\pi\\right) \\end{cases} \\] 相互独立且都服从标准正态分布。 习题20 解： 容易知道，联合分布的密度函数为\\(p(x,y)=1/\\pi\\)。 （1）\\(R^2\\)的分布函数： \\[ F_1(r^2)=P\\{R^2\\le r^2\\}=\\int_{x^2+y^2\\le r^2} p(x,y)\\mathrm dx\\mathrm dy=r^2 \\] 从而\\(R^2\\sim U(0,1)\\)。 （2）不妨用\\(A(\\theta,R^2)\\)表示圆\\(x^2+y^2\\le R^2\\)中弧度为\\(\\theta\\)的扇形区域，则\\(\\theta\\)的分布函数： \\[ F_2(z)=P\\{\\theta\\le z\\}=\\int_{A(z,1)} p(x,y)\\mathrm dx\\mathrm dy=\\frac z{2\\pi} \\] 从而\\(\\theta\\sim U(0,2\\pi)\\)。 （3）\\((R^2,\\theta)\\)的联合分布函数： \\[ F(r^2,z)=P\\{R^2\\le r^2,\\theta\\le z\\}=\\int_{A(z,r^2)} p(x,y)\\mathrm dx\\mathrm dy=r^2\\cdot\\frac{z}{2\\pi}=F_1(r^2)\\cdot F_2(z) \\] 从而两者独立。 习题21 解： 1、由于 \\[ F(x)=\\frac{G(x)-G(a)}{G(b)-G(a)}=\\frac{P\\{a&lt;X\\le x\\}}{P\\{a&lt;X\\le b\\}}=P\\{X\\le x|a&lt;X\\le b\\} \\] 2、这不是显然吗…（嚣张doge）。 习题22 解： 1、\\(p_1=\\lambda_1\\)显然，不妨记\\(S_n=\\sum_{k=1}^np_k\\)，由于 \\[ 1-\\lambda_n=\\frac{1-S_n}{1-S_{n-1}} \\] 则 \\[ (1-\\lambda_1)\\cdots(1-\\lambda_{n-1})\\lambda_n=(1-p_1)\\frac{1-S_2}{1-S_{1}}\\cdot\\frac{1-S_3}{1-S_{2}}\\cdots\\frac{1-S_{n-1}}{1-S_{n-2}}\\frac{p_n}{1-S_{n-1}}=p_n \\] 2、由算法过程可以知道，取\\(X=k\\)当且仅当前\\(k-1\\)个\\((0,1)\\)均匀随机数大于等于对应的\\(\\lambda_i\\)，并且第\\(k\\)个\\((0,1)\\)均匀随机数小于\\(\\lambda_k\\)。而第\\(i\\)个\\((0,1)\\)均匀随机数大于\\(\\lambda_i\\)的概率为\\(p_i=1-\\lambda_i\\)，从而取\\(X=k\\)的概率为 \\[ p=p_1\\cdot p_2\\cdots p_{k-1}(1-p_k)=(1-\\lambda_1)\\cdots(1-\\lambda_{k-1})\\lambda_k=p_k \\] 从而算法是合理的。 3、上述算法不就是生成\\(X\\)分布的随机数吗…明显的有效性？大概是一个几何分布的“无记忆性”，\\(\\lambda_k\\)是一个常数，当生成随机数数量较大时也很有效，因为不需要计算所有的\\(\\lambda_k\\)。 习题23 解： 1、几何分布，\\(p=\\lambda\\)。 2、… "],["rng-multi.html", "6 随机向量和随机过程的随机数 6.1 笔记 6.2 习题", " 6 随机向量和随机过程的随机数 6.1 笔记 将书上的一些函数例子自己重新实现一遍。 6.1.1 多项分布随机数 利用条件分布的方法： # 输入 # n: 输出随机数个数 # m: 独立试验次数 # prob: 每次使用出现结果概率 # 输出 # n行r列，r为每次试验可能出现的结果个数 rng.multinom &lt;- function(n, m, prob) { r &lt;- length(prob) pp &lt;- cumsum(prob[-r]) # 预先计算二项分布各p值 pp &lt;- prob[-1]/(1-pp) res &lt;- matrix(0,n,r) # 输出结果 mr &lt;- m # 按列循环 for(j in seq(r)) { if(j==1) res[,1] &lt;- rbinom(n,m,prob[[1]]) else{ mr &lt;- mr-res[,j-1] res[,j] &lt;- rbinom(n,mr,pp[j-1]) } } res } 测试： prob &lt;- c(0.1, 0.3, 0.6) x &lt;- rng.multinom(100000, 5, prob) # (1,2,2)的理论概率： p122 &lt;- 30*prod(prob^c(1,2,2)); p122 #&gt; [1] 0.0972 # 模拟结果 mean(x[,1]==1 &amp; x[,2]==2 &amp; x[,3]==2) #&gt; [1] 0.09752 # (1,1,3)的理论概率： p113 &lt;- 20*prod(prob^c(1,1,3)); p113 #&gt; [1] 0.1296 # 模拟结果 mean(x[,1]==1 &amp; x[,2]==1 &amp; x[,3]==3) #&gt; [1] 0.12853 6.1.2 多元正态分布模拟 利用对协方差矩阵的Cholesky分解。 # 输入 # n: 生成随机数个数 # mu: 均值向量 # Sigma: 协方差矩阵 # 输出 # n行m列矩阵，m为维数 rng.mnorm &lt;- function(n, mu, Sigma) { m &lt;- length(mu) M &lt;- chol(Sigma) # Sigma = M&#39; M y &lt;- matrix(rnorm(n*m),n,m)%*%M x &lt;- mu+t(y) t(x) } 测试： x &lt;- rng.mnorm(1000, c(3,2), rbind(c(4, 1), c(1, 1))) plot(x[,1], x[,2], type=&quot;p&quot;, cex=0.1) abline(v=3, h=2, col=&quot;green&quot;) var(x) #&gt; [,1] [,2] #&gt; [1,] 3.8500295 0.9318417 #&gt; [2,] 0.9318417 0.9670824 6.2 习题 习题1 # 输入： # n: 生成随机数个数 # ni: 各个颜色球的个数向量 # m: 总共抽取的球个数 # 输出 # n行r列矩阵，其中r为球的颜色数量 rng.hyper &lt;- function(n,ni,m) { r &lt;- length(ni) N &lt;- sum(ni) # 总球数 N &lt;- N-cumsum(ni) x &lt;- matrix(0,n,r) xr &lt;- rep(0,n) # 按列循环 for(j in seq(r)) { if(j==1) x[,1] &lt;- rhyper(n,ni[[1]],N[[1]],m) else{ xr &lt;- xr + x[,j-1] x[,j] &lt;- rhyper(n,ni[[j]],N[[j]],m-xr) } } x } 测试： n &lt;- 10000 ni &lt;- c(20,30,50) m &lt;- 10 x &lt;- rng.hyper(n,ni,m) apply(x,2,sum)/n/10 #&gt; [1] 0.20152 0.30026 0.49822 接下来采用试验计数的方法验证一下上面定义的函数： trial.hyper &lt;- function(n,ni,m) { r &lt;- length(ni) x &lt;- matrix(0,n,r) s &lt;- rep(1:r,times = ni) # 样本数据 for(i in seq(n)) { y &lt;- sample(s,m,replace = FALSE) # 不放回抽样 y &lt;- factor(y,levels=(1:r)) t &lt;- table(y) #计数 x[i,] &lt;- as.integer(t) } x } # 测试 n &lt;- 10000 ni &lt;- c(20,30,50) m &lt;- 10 x &lt;- trial.hyper(n,ni,m) apply(x,2,sum)/n/10 #&gt; [1] 0.19965 0.29942 0.50093 非常接近，定义的函数应该是可行的。 "]]
