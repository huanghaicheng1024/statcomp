[["index.html", "统计计算 背景", " 统计计算 Huang 2021-08-23 背景 开始学习《统计计算》，主要参考李东风老师的网页教材，链接：https://www.math.pku.edu.cn/teachers/lidf/docs/statcomp/html/_statcompbook/index.html 。 2021-7-6 "],["intro-error.html", "1 误差 1.1 习题", " 1 误差 library(purrr) 1.1 习题 习题1 编程计算机器的值。 解： R语言中可以使用 .Machine$double.eps #&gt; [1] 2.22e-16 .Machine下面列有很多误差相关的机器参数，有需要的可以查阅这里。 习题2 设某正数\\(a\\)四舍五入后保留了\\(p\\)位有效数字，表示成\\(a^* = (0.a_1a_2\\cdots a_p)_{10}\\times10^m(a_1\\ne0)\\)。 估计其绝对误差和相对误差的范围， 并分析误差与有效数字位数\\(p\\)的关系。 解： 容易知道，\\(m\\ge p\\)。先通过一个例子直观理解一下，不妨取\\(a=12546\\)，当取\\(p=3\\)，有\\(a^*=0.125\\times 10^5=12500\\)，当取\\(p=4\\)，有\\(a^*=0.1255\\times 10^5=12550\\)。 所以可以得到，\\(m\\)实际上是正数\\(a\\)的位数，而\\(p\\)则是要保留的有效数字的位数。 其绝对误差： \\[ \\Delta = a-a^*\\le 0.5\\times10^{m-p} \\] 利用\\(a\\ge10^m\\)，其相对误差： \\[ \\delta = \\frac{\\Delta}{a} \\le\\frac{0.5\\times10^{m-p}}{10^m}=0.5\\times10^{-p} \\] 习题3 解： 先定义通项： myfun &lt;- function(n) { (-1)^(n+1)/n } n &lt;- 10^6 S &lt;- 0 for (i in 1:n) { S &lt;- S+myfun(i) } abs(S-log(2)) #&gt; [1] 5e-07 S &lt;- 0 for (i in 1:n) { S &lt;- S+myfun(n+1-i) } abs(S-log(2)) #&gt; [1] 5e-07 S &lt;- 0 l &lt;- vector(&quot;double&quot;,n/2) for (i in 1:(n/2)) { l[[i]] &lt;- myfun(2*i-1)+myfun(2*i) } for (i in l) { S &lt;- S+i } abs(S-log(2)) #&gt; [1] 5e-07 l &lt;- vector(&quot;double&quot;,n/2) for (i in 1:(n/2)) { l[[i]] &lt;- 1/(2*n*2*(n-1)) } for (i in l) { S &lt;- S+i } abs(S-log(2)) #&gt; [1] 3.75e-07 第4种方法精度更高。 习题4 解： x &lt;- 1:4 myfun1 &lt;- function(x, k=10) { S &lt;- 1 for (i in 1:k) { m &lt;- (-x)^i/factorial(i) S &lt;- S+m } S } myfun2 &lt;- function(x, k=10) { S &lt;- 1 for (i in 1:k) { m &lt;- x^i/factorial(i) S &lt;- S+m } 1/S } s1 &lt;- map_dbl(x,myfun1) s2 &lt;- map_dbl(x,myfun2) s &lt;- exp(-x) df &lt;- data.frame(x,s1=abs(s1-s),s2=abs(s2-s)) knitr::kable(df) x s1 s2 1 0.000 0 2 0.000 0 3 0.004 0 4 0.078 0 方法1的误差太大了，不妨增大\\(k\\)值： s1 &lt;- map_dbl(x,myfun1,k=100) s2 &lt;- map_dbl(x,myfun2) s &lt;- exp(-x) df &lt;- data.frame(x,s1=abs(s1-s),s2=abs(s2-s)) knitr::kable(df) x s1 s2 1 0 0 2 0 0 3 0 0 4 0 0 误差瞬间下去，说明方法1的收敛比较慢。以\\(x=4\\)为例，探究两个方法的收敛速度： x &lt;- 4 k &lt;- 1:50 s1 &lt;- map_dbl(k,myfun1,x=x) s2 &lt;- map_dbl(k,myfun2,x=x) s &lt;- exp(-x) opar &lt;- par(no.readonly = TRUE) plot(k,abs(s1-s),&quot;l&quot;,ylab=&quot;&quot;) lines(k,abs(s2-s),lty=2,col=&quot;red&quot;) title(ylab=&quot;绝对误差&quot;) legend(&quot;topright&quot;,c(&quot;公式（1）&quot;,&quot;公式（2）&quot;),lty=c(1,2),col=c(&quot;black&quot;,&quot;red&quot;)) par(opar) 可以看到公式（1）的收敛速度一开始是很慢的。 习题5 解： 载入数据： x &lt;- c(249, 254, 243, 268, 253, 269, 287, 241, 273, 306303, 280, 260, 256, 278, 344, 304, 283, 310) n &lt;- length(x) 公式1： s1 &lt;- 0 for (i in x) { s1 &lt;- signif(s1+signif(i^2,digits = 6),digits = 6) } s1 &lt;- signif(s1-n*mean(x),digits = 6) s1 &lt;- signif(s1/(n-1),digits = 6) 公式2： s2 &lt;- 0 m &lt;- mean(x) for (i in x) { s2 &lt;- signif(s2+signif((i-m)^2,digits = 6),digits = 6) } s2 &lt;- signif(s2/(n-1),digits = 6) 比较： df &lt;- data.frame(`函数直接计算`=var(x),`公式1`=s1,`公式2`=s2) knitr::kable(df) 函数直接计算 公式1 公式2 5.2e+09 5.52e+09 5.2e+09 公式2比公式1更精确，公式1先计算平方求和，值太大，保留6位有效数字之后损失较多。 习题6 解： "],["intro-summary.html", "2 概括统计量 2.1 习题", " 2 概括统计量 library(tidyverse) #&gt; -- Attaching packages ----- tidyverse 1.3.0 -- #&gt;  ggplot2 3.3.2  dplyr 1.0.2 #&gt;  tibble 3.0.3  stringr 1.4.0 #&gt;  tidyr 1.1.1  forcats 0.5.0 #&gt;  readr 1.3.1 #&gt; -- Conflicts -------- tidyverse_conflicts() -- #&gt; x dplyr::filter() masks stats::filter() #&gt; x dplyr::lag() masks stats::lag() 2.1 习题 习题1 解： skewness &lt;- function(x) { n &lt;- length(x) y &lt;- (x-mean(x))/sd(x) phi &lt;- n*sum(y^3)/(n-1)/(n-2) phi } 测试： x &lt;- c(8.75, 10.37, 8.33, 13.19, 10.66, 8.36, 10.97, 11.48, 11.15, 9.39) skewness(x) #&gt; [1] 0.3516643 习题2 解： 定义函数： quantile_est &lt;- function(x, p) { p &lt;- as.double(p) if(p&lt;0 | p&gt;1) stop(&quot;The &#39;p&#39; is out of [0,1].&quot;) else if(p==0) xp &lt;- min(x) else if(p==1) xp &lt;- max(x) else{ n &lt;- length(x) t &lt;- table(x) r &lt;- as.double(names(t)) i &lt;- floor(p*(n+1/3)+1/3) # xq左侧的x(i) j &lt;- i+t[names(t)==r[i]] # xq右侧x(j) k &lt;- (j-i)/(n+1/3)/(r[i+1]-r[i]) xp &lt;- p-(i-1/3)/(n+1/3)+k*r[i] xp &lt;- xp/k } names(xp) &lt;- p xp } 与quantile()以及真实分位数的比较： x &lt;- rnorm(1000) tbl &lt;- tibble(p = seq(0,1,by = 0.1)) tbl[&quot;real&quot;] &lt;- qnorm(tbl$p) tbl[&quot;quantile&quot;] &lt;- quantile(x,tbl$p) tbl[&quot;quantile_est&quot;] &lt;- map_dbl(tbl$p,quantile_est,x=x) tbl %&gt;% ggplot(aes(x=p))+ geom_line(aes(y=real,color=&quot;real&quot;))+ geom_line(aes(y=quantile,color=&quot;quantile&quot;))+ geom_line(aes(y=quantile_est,color=&quot;quantile_est&quot;),linetype=2)+ ylab(&quot;value&quot;) 可以看到，自定义函数跟quantile()函数得到的值重合度非常高，与真实分位数也差别不大。 习题3 解： 3.2.1 证明： \\[ \\bar{x}_n = \\frac1n\\sum_{i=1}^nx_i=\\frac{n-1}n\\times\\frac{\\sum_{i=1}^{n-1}x_i}{n-1}+\\frac{x_n}n=\\frac{n-1}n\\bar{x}_{n-1}+\\frac{x_n}n \\] 3.2.2 证明： \\[ \\begin{align} (n-1)S_n^2 &amp;= \\sum_{i=1}^n(x_i-\\bar x_n)^2\\\\ &amp;= \\sum_{i=1}^n(x_i-\\bar x_{n-1}+\\bar x_{n-1}-\\bar x_n)^2\\\\ &amp;= \\sum_{i=1}^n(x_i-\\bar x_{n-1})^2+2(\\bar x_{n-1}-\\bar x_n)\\sum_{i=1}^n(x_i-\\bar x_{n-1})+\\sum_{i=1}^n(\\bar x_{n-1}-\\bar x_n)^2\\\\ &amp;= (n-2)S_{n-1}^2+(x_n-\\bar x_{n-1})^2-2n(\\bar x_n-\\bar x_{n-1})^2+n(\\bar x_{n-1}-\\bar x_n)^2\\\\ &amp;= (n-2)S_{n-1}^2+(x_n-\\bar x_{n-1})^2-n(\\bar x_n-\\bar x_{n-1})^2\\\\ &amp;= (n-2)S_{n-1}^2+(x_n-\\bar x_{n-1})^2-n(\\frac{x_n}{n}-\\frac{\\bar x_{n-1}}{n})^2\\\\ &amp;= (n-2)S_{n-1}^2+(x_n-\\bar x_{n-1})^2-\\frac1n(x_n-\\bar x_{n-1})^2\\\\ &amp;= (n-2)S_{n-1}^2+\\frac{n-1}n(x_n-\\bar x_{n-1})^2 \\end{align} \\] 从而： \\[ S_n^2 = \\frac{n-2}{n-1}S_{n-1}^2+\\frac{1}n(x_n-\\bar x_{n-1})^2 \\] 习题4 解： 求均值的递推公式一样，直接向量化运算就行. 求协方差的递推算法跟求方差类似： 由于 \\[ \\Sigma_n = \\frac{1}{n-1}\\sum_{i=1}^n(x_i-\\bar x_n)(x_i-\\bar x_n)^T \\] 从而： \\[ \\begin{align} (n-1)\\Sigma_n &amp;= \\sum_{i=1}^n(x_i-\\bar x_n)(x_i-\\bar x_n)^T\\\\ &amp;= \\sum_{i=1}^n(x_i-\\bar x_{n-1}+\\bar x_{n-1}-\\bar x_n)(x_i-\\bar x_{n-1}-\\bar x_{n-1}+\\bar x_n)^T\\\\ &amp;= (n-2)\\Sigma_{n-1}+\\frac{n-1}{n}(x_n-\\bar x_{n-1})(x_n-\\bar x_{n-1})^T \\end{align} \\] 即 \\[ \\Sigma_n = \\frac{n-2}{n-1}\\Sigma_{n-1}+\\frac{1}{n}(x_n-\\bar x_{n-1})(x_n-\\bar x_{n-1})^T \\] "],["intro-graph.html", "3 统计图形 3.1 习题", " 3 统计图形 library(tidyverse) library(GGally) #&gt; Registered S3 method overwritten by &#39;GGally&#39;: #&gt; method from #&gt; +.gg ggplot2 set.seed(1024) 3.1 习题 习题1 解： opar &lt;- par(no.readonly = TRUE) par(mfrow=c(5,3)) par(mar=rep(2,4)) #第一种 n=c(10, 20, 30, 50, 100) for(i in seq_along(n)) { hist(rnorm(n[[i]]),freq = FALSE,main = paste(&quot;n=&quot;,n[[i]],&quot;，标准正态&quot;)) hist(exp(rnorm(n[[i]])),freq = FALSE,main = paste(&quot;n=&quot;,n[[i]],&quot;，对数正态&quot;)) hist(rcauchy(n[[i]]),freq = FALSE,main = paste(&quot;n=&quot;,n[[i]],&quot;，柯西分布&quot;)) } par(opar) 习题2 解： iris %&gt;% ggpairs(aes(color=Species,shape=Species), columns = 1:4, upper = list(continuous = &quot;points&quot;)) "],["rng-uniform.html", "4 均匀分布随机数生成 4.1 习题", " 4 均匀分布随机数生成 set.seed(1024) 4.1 习题 习题1 易证。 习题2 解： 将[0,1]等分为\\(k\\)段，每个端点分别为\\(x_i=i/k,i=0,\\dots,k\\)，考虑左闭右开区间，如果给定点\\(x\\)落在\\(x_i\\le x&lt;x_{i+1}\\)中，有\\(i/k\\le x&lt;(i+1)/k\\)，即\\(i\\le kx &lt;i+1\\)，\\(\\lfloor kx \\rfloor=i\\)，若\\(x&lt;0\\)或\\(x&gt;1\\)报错。 runif.chisq.test &lt;- function(x, k) { y &lt;- rep(0,k) for (i in seq_along(x)) { j &lt;- floor(k*x[[i]]) # 第j段 if(x[[i]]==1){ y[[k]] &lt;- y[[k]]+1 }else if(j&lt;0 | j&gt;=k){ stop(&quot;there is value of x out of [0,1]&quot;) }else{ y[[j+1]] &lt;- y[[j+1]]+1 } } chisq.test(y) } 测试一下： x &lt;- runif(1000) k &lt;- 10 runif.chisq.test(x,k) #&gt; #&gt; Chi-squared test for given probabilities #&gt; #&gt; data: y #&gt; X-squared = 3.06, df = 9, p-value = 0.9619 通过检验。 x &lt;- rnorm(1000) x &lt;- x[x&gt;=0&amp;x&lt;=1] k &lt;- 10 runif.chisq.test(x,k) #&gt; #&gt; Chi-squared test for given probabilities #&gt; #&gt; data: y #&gt; X-squared = 20.047, df = 9, p-value = 0.01763 显著性水平0.05下拒绝原假设。 习题3 解： 类似地，这里对输入数据的最小值与最大值之间等分\\(k\\)段，每个端点分别为\\(x_i=i/k,i=0,\\dots,k\\)，考虑左闭右开区间，如果给定点\\(x\\)落在\\(x_i\\le x&lt;x_{i+1}\\)中，有\\(i/k\\le x&lt;(i+1)/k\\)，即\\(i\\le kx &lt;i+1\\)，\\(\\lfloor kx \\rfloor=i\\)。 # F为分布函数 random.chisq.test &lt;- function(x, k, F) { library(purrr) xmin &lt;- min(x) xmax &lt;- max(x) d &lt;- xmax-xmin j &lt;- floor(k*(x-xmin)/d) y &lt;- rep(0,k+2) for (i in seq_along(x)) { if(x[[i]]==max(x)){ y[[k+1]] &lt;- y[[k+1]]+1 }else{ y[[j[[i]]+2]] &lt;- y[[j[[i]]+2]]+1 } } p &lt;- seq(xmin,xmax,length.out = k+1) %&gt;% map_dbl(F) p &lt;- c(p[[1]],diff(p),1-p[[k+1]]) chisq.test(y,p = p) } 测试： x &lt;- rnorm(1000) k &lt;- 10 random.chisq.test(x,k,pnorm) #&gt; Warning in chisq.test(y, p = p): Chi-squared approximation may be incorrect #&gt; #&gt; Chi-squared test for given probabilities #&gt; #&gt; data: y #&gt; X-squared = 8.422, df = 11, p-value = 0.6751 x &lt;- runif(1000) k &lt;- 10 random.chisq.test(x,k,pnorm) #&gt; #&gt; Chi-squared test for given probabilities #&gt; #&gt; data: y #&gt; X-squared = 2044.9, df = 11, p-value &lt; 2.2e-16 通过测试。 习题4 解： 这个应该是下一节的内容，不过无所谓啦。先得到它的分布函数为 \\[ F(x) = \\frac12x+\\frac12x^2,\\quad0\\le x\\le1 \\] 1、逆变换法： 先求\\(F^{-1}\\)为： \\[ F^{-1}(u) = -\\frac12+\\sqrt{2u+\\frac14} \\] 从而定义函数： rng.x1 &lt;- function(n) { -0.5+sqrt(2*runif(n)+0.25) } 测试： n &lt;- 1000 x &lt;- rng.x1(n) hist(x,freq = FALSE) y &lt;- seq(0,1,0.01) z &lt;- 0.5+y lines(y,z,col=&quot;red&quot;) 基本吻合。 2、舍选法 就是拒绝采样啦，取提议分布为均匀分布\\(U[0,1]\\)，则\\(c=1.5\\). rng.x2 &lt;- function(n) { x &lt;- runif(n) y &lt;- runif(n,0,1.5) s &lt;- x[y&lt;=0.5+x] list(samples = s, eff = length(s)/n) } 测试： n &lt;- 1000 x &lt;- rng.x2(n) hist(x$samples,freq = FALSE) y &lt;- seq(0,1,0.01) z &lt;- 0.5+y lines(y,z,col=&quot;red&quot;) 基本吻合。看一下效率： x$eff #&gt; [1] 0.669 理论上的效率为\\(2/3\\)。 3、复合法 将梯形面积分解为一个矩形跟一个三角形，两者面积都是0.5。 rng.x3 &lt;- function(n) { i &lt;- runif(n) x &lt;- runif(n) # 小于等于0.5保持值，大于0.5开平方 x[i&gt;0.5] &lt;- sqrt(x[i&gt;0.5]) x } 测试： n &lt;- 1000 x &lt;- rng.x3(n) hist(x,freq = FALSE) y &lt;- seq(0,1,0.01) z &lt;- 0.5+y lines(y,z,col=&quot;red&quot;) 比较算法的效率？除了舍选法会拒绝点之外，其余两者算法都是全部接受点的。看一下函数的运行时间吧，虽然这个比较粗糙，因为跟算法编码的设计有关，不一定是算法本身的问题： n &lt;- 10000000 t1.1 &lt;- proc.time() x &lt;- rng.x1(n) t1.2 &lt;- proc.time() t1 &lt;- t1.2-t1.1 t2.1 &lt;- proc.time() x &lt;- rng.x2(n) t2.2 &lt;- proc.time() t2 &lt;- t2.2-t2.1 t3.1 &lt;- proc.time() x &lt;- rng.x3(n) t3.2 &lt;- proc.time() t3 &lt;- t3.2-t3.1 df &lt;- data.frame(`逆变换法`=t1[3][[1]],`舍选法`=t2[3][[1]],`复合法`=t3[3][[1]]) knitr::kable(df) 逆变换法 舍选法 复合法 0.52 1.06 1.1 总的来说，逆变换法要更好点，舍选法要稍差点。 "],["rng-nonuni.html", "5 非均匀随机数生成 5.1 笔记 5.2 习题", " 5 非均匀随机数生成 library(tidyverse) 5.1 笔记 5.1.1 用逆变换法生成离散型随机数 定理6.2非常重要，主要的思路就是明确概率空间点集，然后求在点集上各点的分布函数值（累加），再生成[0,1]均匀分布随机数，找到对应分布函数值大于等于它并最与它接近的点值，就是服从给定分布的一个随机数。书本上一开始定义是对应分布函数值大于等于它并最与它接近的点值，后来代码又变成了对应分布函数值小于于等于它并最与它接近的点值，有点莫名其妙。 5.1.2 R中的离散分布函数 看一下对于离散分布，R中的分布函数定义是\\(P\\{X\\le x\\}\\)还是\\(P\\{X&lt; x\\}\\)。考虑\\(b(3,0.5)\\)， pbinom(1,3,0.5) #&gt; [1] 0.5 也即是\\(F(1)=0.5\\).由于\\(P\\{X\\le 1\\}=P\\{X= 0,1\\}=0.5\\)，所以在R中分布函数的定义为\\(F(x)=P\\{X\\le x\\}\\). 5.2 习题 习题1 解： 先定义一个函数： myfun &lt;- function(n) { x &lt;- rep(2,n) i &lt;- runif(n) j &lt;- i&lt;1/3 x[j] &lt;- 1 list(samples = x, p = mean(j)) } n &lt;- c(100,1000,10000) p &lt;- n %&gt;% map(myfun) %&gt;% map_dbl(~.$p) knitr::kable(data.frame(n=n,p=p),align = &quot;cc&quot;) n p 100 0.3300 1000 0.3230 10000 0.3377 第4问不太看得懂，先占坑。 习题2 解： 仿照例6.2： rng.pk &lt;- function(n, pk) { if(sum(pk)!=1) stop(&quot;the sum of pk must be 1&quot;) m &lt;- length(pk) Fvs &lt;- c(0,cumsum(pk[-m])) p &lt;- runif(n) x &lt;- vector(&quot;integer&quot;,n) for (i in seq_along(x)) { j &lt;- max(which(Fvs &lt;= p[[i]])) x[i] &lt;- j } x } 测试： x &lt;- rng.pk(1000,c(0.1,0.3,0.6)) prop.table(table(x))*100 #&gt; x #&gt; 1 2 3 #&gt; 10.3 31.4 58.3 习题3 解： 先进行统计模拟。 # n次实验 draw.card &lt;- function(n) { x &lt;- vector(&quot;double&quot;,n) for (i in seq_along(x)) { s &lt;- sample(1:54,replace = FALSE) # 1次实验结果 x[[i]] &lt;- sum(s==(1:54)) } x } # 取n=100000 n &lt;- 100000 x &lt;- draw.card(n) sum(x==0) #&gt; [1] 36806 mean(x) #&gt; [1] 0.99936 var(x) #&gt; [1] 0.9978296 均值跟方差都是1. 再进行理论推导。 容易知道，\\(T\\in\\{1,2,\\cdots,54\\}\\)为离散随机变量，需要用到全错位排列，不妨设\\(D_n\\)为总数为\\(n\\)的全错位排列数，有递推公式\\(D_n=(n-1)(D_{n-1}+D_{n-2})\\)，不妨补充定义\\(D_0=1\\)，则 \\[ P\\{T_n=0\\} = C_n^0\\cdot D_n/n!\\\\ P\\{T_n=1\\} = C_n^1\\cdot D_{n-1}/n!\\\\ \\cdots \\\\ P\\{T_n=k\\} = C_n^k\\cdot D_{n-k}/n!\\\\ \\cdots \\\\ P\\{T_n=n-1\\} = C_n^{n-1}\\cdot D_{1}/n!\\\\ P\\{T_n=n\\} = C_n^{n}\\cdot D_{0}/n!\\\\ \\] 题中当\\(n=54\\)，还是得借助计算机： # 先定义函数求[D_0,...,D_n] D.n &lt;- function(n) { D &lt;- vector(&quot;integer&quot;, n+1) for (i in seq_along(D)) { if(i==1) D[[i]] &lt;- 1 # D_0 else if(i==2) D[[i]] &lt;- 0 # D_1 else{ D[[i]] &lt;- (i-2)*(D[[i-1]]+D[[i-2]]) # D_{i-1} } } D } n &lt;- 54 i &lt;- n:0 P &lt;- D.n(n)*choose(n,i)/factorial(n) # P{T=n,...,0} # 求均值 m &lt;- sum(i*P) # 求方差 v &lt;- sum((i-m)^2*P) print(paste(&quot;均值=&quot;,m,&quot;,方差=&quot;,v,sep=&quot;&quot;)) #&gt; [1] &quot;均值=0.999999999999983,方差=0.999999999999983&quot; 考虑到误差，可以认为理论值的均值跟方差都是1. 习题4 解： 先定义投掷色子的函数： # 返回n次实验的结果 roll.dice &lt;- function(n) { x &lt;- rep(0, n) for (j in seq_along(x)) { l &lt;- rep(0,11) while (min(l)==0) { i &lt;- sum(sample.int(6, size=2, replace=TRUE)) # 投掷两次色子 l[[i-1]] &lt;- l[[i-1]]+1 x[[j]] &lt;- x[[j]]+1 } } x } # 开始模拟 n &lt;- 100000 x &lt;- roll.dice(n) mean(x) #&gt; [1] 61.1509 var(x) #&gt; [1] 1283.881 习题7 解： 这里需要注意的是，负二项分布的定义主要有两种，一种如题所示，另一种是独立重复试验中第\\(r\\)次成功所经历的失败次数（R函数的定义）。此外，关于几何分布也一样，R函数的定义是描述了独立重复试验中首次成功所经历的失败次数。 1、考虑几何分布跟负二项分布的关系。几何分布描述了独立重复试验中首次成功所需的试验次数，而负二项分布描述了独立重复试验中第\\(r\\)次成功所需的试验次数，则可以产生\\(r\\)个几何分布随机数，求和就是一个负二项分布随机数： rng.nbinom.1 &lt;- function(n, p, r) { y &lt;- matrix(rgeom(n*r,p)+1,n,r) # n行r列 x &lt;- apply(y, 1, sum) x } # 测试 n &lt;- 1000 p &lt;- 0.3 r &lt;- 3 x &lt;- rng.nbinom.1(n,p,r) y &lt;- 0:50 # 失败次数 yy &lt;- dnbinom(y,size = r,prob = p) hist(x,breaks=15,freq=FALSE) lines(y+r,yy,col=&quot;red&quot;) 2、直接利用负二项分布的概率分布，由于负二项分布： \\[ P\\{x=k\\} = \\binom{k-1}{r-1}p^r(1-p)^{k-r},\\quad k=r,r+1,\\cdots \\] 考虑分布函数： \\[ \\begin{align} F(k) &amp;= P\\{x\\le k\\}= P\\{\\text{在前k次实验至少成功r次}\\}\\\\ &amp;= 1-P\\{\\text{在前k次实验成功小于r次}\\}\\\\ &amp;= 1-\\sum_{i=0}^{r-1}P\\{\\text{在前k次实验成功i次}\\}\\\\ &amp;= 1-\\sum_{i=0}^{r-1}\\binom{k}{i}p^i(1-p)^{k-i}\\\\ &amp;:= 1-BS(k,r,p) \\quad k=r,r+1,\\cdots \\end{align} \\] 所以生成随机数\\(X\\)的方法为当且仅当\\(F(k-1)&lt; U\\le F(k)\\)取\\(X=k\\)。这又等价于 \\[ BS(k,r,p)\\le U &lt;BS(k-1,r,p) \\] 取 \\[ \\begin{align} X &amp;= \\min\\{k:BS(k,r,p)\\le U\\} \\end{align} \\] 定义函数： rng.nbinom.2 &lt;- function(n, p, r) { # 先定义BS函数 BS &lt;- function(k.,r.,p.) { i &lt;- 0:(r.-1) sum(choose(k.,i)*p.^i*(1-p.)^(k.-i)) } x &lt;- vector(&quot;integer&quot;, n) u &lt;- runif(n) for (j in seq_along(x)) { k &lt;- r # 初值 while (BS(k,r,p)&gt;u[[j]]) { k &lt;- k+1 } x[[j]] &lt;- k } x } # 测试 n &lt;- 1000 p &lt;- 0.3 r &lt;- 3 x &lt;- rng.nbinom.2(n,p,r) y &lt;- 0:50 # 失败次数 yy &lt;- dnbinom(y,size = r,prob = p) hist(x,breaks=15,freq=FALSE) lines(y+r,yy,col=&quot;red&quot;) 习题8 解： 1、先求分布函数的反函数： \\[ F^{-1}(u) = u^n \\] # m:随机数序列长度 # n:参数n rng.beta.1 &lt;- function(m, n) { u &lt;- runif(m) x &lt;- u^n x } # 测试 n &lt;- c(1,2,3,4) m &lt;- 1000 y &lt;- seq(0,1,0.01) opar &lt;- par(no.readonly = TRUE) par(mfrow=c(2,2)) for (i in seq_along(n)) { x &lt;- rng.beta.1(m, n[[i]]) hist(x,freq = FALSE,main=paste(&quot;n=&quot;,n[[i]],sep = &quot;&quot;)) lines(y,dbeta(y,1/n[[i]],1),col=&quot;red&quot;) } par(opar) 2、先求分布函数的反函数： \\[ F^{-1}(u) = u^{1/n} \\] # m:随机数序列长度 # n:参数n rng.beta.2 &lt;- function(m, n) { u &lt;- runif(m) x &lt;- u^{1/n} x } # 测试 n &lt;- c(1,2,3,4) m &lt;- 1000 y &lt;- seq(0,1,0.01) opar &lt;- par(no.readonly = TRUE) par(mfrow=c(2,2)) for (i in seq_along(n)) { x &lt;- rng.beta.2(m, n[[i]]) hist(x,freq = FALSE,main=paste(&quot;n=&quot;,n[[i]],sep = &quot;&quot;)) lines(y,dbeta(y,n[[i]],1),col=&quot;red&quot;) } par(opar) 3、先求分布函数的反函数： \\[ F^{-1}(u) = \\sin(\\frac{\\pi u}{2}) \\] rng.sin &lt;- function(n) { u &lt;- runif(n) sin(pi*u/2) } # 测试 n &lt;- 1000 x &lt;- rng.sin(n) hist(x,freq = FALSE) curve(2/(pi*sqrt(1-x^2)),0,1,add = TRUE,col=&quot;red&quot;) 4、先求分布函数的反函数： \\[ F^{-1}(u) = \\tan(\\pi u) \\] rng.tan &lt;- function(n) { u &lt;- runif(n) tan(pi*u) } # 测试 n &lt;- 1000 x &lt;- rng.tan(n) hist(x,freq = FALSE,breaks = 1000,xlim=c(-50,50),ylim=c(0,0.3)) curve(1/(pi*(1+x^2)),-50,50,add = TRUE,col=&quot;red&quot;) 5、先求分布函数的反函数： \\[ F^{-1}(u) = \\arcsin(u) \\] rng.asin &lt;- function(n) { u &lt;- runif(n) asin(u) } # 测试 n &lt;- 1000 x &lt;- rng.asin(n) hist(x,freq = FALSE) curve(cos(x),0,pi/2,add = TRUE,col=&quot;red&quot;) 6、先求分布函数的反函数： \\[ F^{-1}(u) = [-\\eta\\log(1-u)]^{1/\\alpha} \\] rng.weibull &lt;- function(n, alpha, eta) { u &lt;- runif(n) (-eta*log(1-u))^(1/alpha) } # 测试 alpha &lt;- c(0.5,1,1.5,2) eta &lt;- c(0.5,1,1.5,2) opar &lt;- par(no.readonly = TRUE) par(mfrow=c(2,2)) # 固定alpha=1 for (i in seq_along(eta)) { x &lt;- rng.weibull(n, alpha[[2]], eta[[i]]) hist(x,freq = FALSE,ylim=c(0,1.5),main = paste(&quot;alpha=1,eta=&quot;,eta[[i]],sep = &quot;&quot;)) curve(alpha[[2]]/eta[[i]]*x^(alpha[[2]]-1)*exp(-x^alpha[[2]]/eta[[i]]),0,5,add = TRUE,col=&quot;red&quot;) } # 固定eta=1 for (i in seq_along(alpha)) { x &lt;- rng.weibull(n, alpha[[i]], eta[[2]]) hist(x,freq = FALSE,main = paste(&quot;eta=1,alpha=&quot;,alpha[[i]],sep = &quot;&quot;)) curve(alpha[[i]]/eta[[2]]*x^(alpha[[i]]-1)*exp(-x^alpha[[i]]/eta[[2]]),0,20,add = TRUE,col=&quot;red&quot;) } par(opar) 习题9 解： 思路是循环批量生成\\(\\exp(1)\\)样本，再判断是否符合要求。关于每次生成样本数的选择，为了期望能循环一次就能得到\\(n\\)个符合要求的样本，可以利用\\(F(0.05)\\)作为批量生成样本中符合要求样本的概率，批量生成样本数可以大致利用\\(n/F(0.05)\\)。 rng.exp &lt;- function(n, x0=0.05) { x &lt;- vector(&quot;double&quot;, n) i &lt;- 0 # 记录符合要求的样本数 while (TRUE) { y &lt;- rexp(floor(n/pexp(x0))) # 分块生成样本，而不是单个生成 idx &lt;- (y&lt;x0) j &lt;- i+sum(idx) # 累计符合要求样本数 if(j&gt;=n){ x[(i+1):n] &lt;- y[idx][1:(n-i)] break() } else if(j==i) next() else{ x[(i+1):j] &lt;- y[idx] } i &lt;- j } x } # 随机模拟 n &lt;- 1000 x &lt;- rng.exp(n) m &lt;- mean(x) 模拟得到的均值约为0.0249387。 下面进行理论推导。直接利用： \\[ E(x)=\\int_0^{0.05}xp(x)\\mathrm dx = \\frac{1-1.05e^{-0.05}}{1-e^{-0.05}} \\] m1 &lt;- (1-1.05*exp(-0.05))/(1-exp(-0.05)) 利用计算机计算得到结果为0.0247917，相差1.4707064^{-4}。 习题10 解： 方法1：逆变换法，仿照例6.2 rng.10.1 &lt;- function(n, m, lambda) { i &lt;- 0:m prob &lt;- exp(-lambda)*lambda^i/factorial(i) # 排序 ord &lt;- order(prob, decreasing = TRUE) i &lt;- i[ord] prob &lt;- prob[ord] Fvs &lt;- c(0, cumsum(prob[1:m])) u &lt;- runif(n) x &lt;- vector(&quot;integer&quot;,n) for (j in 1:n) { x[j] &lt;- i[[max(which(Fvs &lt;= u[[j]]))]] } x } 方法2：注意到\\(P\\{X=k\\}=e^{-\\lambda}\\frac{\\lambda^k}{k!},k=0,1,\\cdots\\)，则\\(X\\)服从泊松分布。故可以生成服从泊松分布的随机数，若小于等于\\(m\\)则保留，否则丢弃，仿照习题9： rng.10.2 &lt;- function(n, m, lambda) { x &lt;- vector(&quot;double&quot;, n) i &lt;- 0 # 记录符合要求的样本数 while (TRUE) { y &lt;- rpois(floor(n/ppois(m,lambda)),lambda) # 分块生成样本，而不是单个生成 idx &lt;- (y&lt;=m) j &lt;- i+sum(idx) # 累计符合要求样本数 if(j&gt;=n){ x[(i+1):n] &lt;- y[idx][1:(n-i)] break() } else if(j==i) next() else{ x[(i+1):j] &lt;- y[idx] } i &lt;- j } x } 测试： # 测试 opar &lt;- par(no.readonly = TRUE) par(mfrow=c(1,2)) n &lt;- 1000 m &lt;- 10 lambda &lt;- 4 x &lt;- rng.10.1(n,m,lambda) y &lt;- rng.10.2(n,m,lambda) hist(x,freq=FALSE,breaks = m+1,ylim=c(0,0.25)) hist(y,freq=FALSE,breaks = m+1,ylim=c(0,0.25)) par(opar) 算是大致一致吧。 习题11 解： 1、逆变换法： 利用条件概率公式，设二项分布的分布函数为\\(F_1\\)： \\[ F(y) = P\\{Y\\le y\\}=\\frac{P\\{k\\le X\\le y\\}}{P\\{X\\ge k\\}}=\\frac{F_1(y)-F_1(k-1)}{1-F_1(k-1)},\\quad y=k,k+1,\\cdots,n \\] 则当 \\[ \\frac{F_1(i-1)-F_1(k-1)}{1-F_1(k-1)}&lt;u\\le \\frac{F_1(i)-F_1(k-1)}{1-F_1(k-1)},\\quad i=k,k+1,\\cdots,n \\] 时取\\(y=i\\)，上述条件又等价于 \\[ F_1(i-1)&lt;(1-F_1(k-1))u+F_1(k-1)\\le F_1(i) \\] 定义函数 # n:输出随机数长度 # size：实验次数 # k：题中参数 rng.11.1 &lt;- function(n, size, k=0, prob=0.5) { x &lt;- vector(&quot;integer&quot;, n) ss &lt;- k:size # 样本空间 Fvs &lt;- pbinom(ss,size,prob) # F_1值 u &lt;- runif(n) u &lt;- u+(1-u)*pbinom(k-1,size,prob) for (i in 1:n) { j &lt;- min(which(Fvs&gt;=u[[i]])) x[[i]] &lt;- ss[[j]] } x } 2、舍选法 密度函数： \\[ P\\{Y=y\\} = F(y)-F(y-1)=\\frac{F_1(y)-F_1(y-1)}{1-F_1(k-1)}=\\frac{P\\{X=y\\}}{1-F_1(k-1)},\\quad y=k,k+1,\\cdots,n \\] # 这里的n表示试投次数 rng.11.2 &lt;- function(n, size, k=0, prob=0.5) { y &lt;- k:size fvs &lt;- dbinom(y,size,prob)/(1-pbinom(k-1,size,prob)) x &lt;- sample(y,n,replace = TRUE) if(k==size){ x &lt;- rep(y, n) fvs &lt;- rep(1, 1) } u &lt;- runif(n,0,min(1,max(fvs))) for (i in seq_along(x)) { if(u[[i]]&gt;fvs[[x[[i]]-k+1]]) x[[i]] &lt;- -1 # 拒绝 } x[x&gt;-1] } 3、理论分析 由于 \\[ P\\{Y=y\\} = F(y)-F(y-1)=\\frac{F_1(y)-F_1(y-1)}{1-F_1(k-1)}=\\frac{P\\{X=y\\}}{1-F_1(k-1)},\\quad y=k,k+1,\\cdots,n \\] 有： # 测试 size &lt;- 10 k &lt;- 3 prob &lt;- 0.5 y &lt;- k:size p &lt;- dbinom(y,size,prob)/(1-pbinom(k-1,size,prob)) # 变换法 n &lt;- 10000 x &lt;- rng.11.1(n,size,k,prob) m1 &lt;- table(x)/n # 拒绝采样 n &lt;- 20000 x &lt;- rng.11.2(n,size,k,prob) m2 &lt;- table(x)/length(x) r &lt;- length(x)/n # 比较结果 df &lt;- data.frame(y=y,p=p,m1=as.double(m1),m2=as.double(m2)) knitr::kable(df,digits = 3) y p m1 m2 3 0.124 0.123 0.125 4 0.217 0.208 0.211 5 0.260 0.264 0.266 6 0.217 0.220 0.211 7 0.124 0.126 0.124 8 0.046 0.048 0.052 9 0.010 0.010 0.010 10 0.001 0.001 0.000 基本上相差不大。 接下来考虑\\(\\alpha=P\\{X\\ge k\\}\\)对拒绝采样接受率的影响，实验中取不同的\\(k\\)用于表示不同的\\(\\alpha\\)。 size &lt;- 20 k &lt;- 0:size prob &lt;- 0.4 n &lt;- 20000 # 试投点数 r &lt;- vector(&quot;double&quot;,length(k)) for(i in seq_along(k)){ x &lt;- rng.11.2(n,size,k[[i]],prob) r[[i]] &lt;- length(x)/n # 接受率 } alpha &lt;- 1-pbinom(k-1,size,prob) plot(alpha,r,type=&quot;p&quot;,pch=16,cex=0.5,col=&quot;blue&quot;) 也不好说\\(\\alpha\\)取什么值时拒绝采样方法不可取，应该是比较小的时候。 习题12 解： 方法1：拒绝采样 先观察一下密度函数： curve(x*exp(-x),0,20,ylab=&quot;p(x)&quot;) 若使用均匀分布作提议分布，容易求得 \\[ \\min p(x) = p(1) = 1/e \\] 采样： # 提议分布为均匀分布 # px为密度函数, # n不是生成px的样本数，而是提议分布的样本数 rejection_sampling_unit &lt;- function(px, n, c,...){ x &lt;- runif(n, ...) # 生成n个随机数 y &lt;- px(x) z &lt;- runif(n, 0, c) d &lt;- (z&lt;=y) output &lt;- list(data = tibble(x,y,z,d), samples = x[d]) return(output) } px &lt;- function(x){ y &lt;- ifelse(x&gt;0,x*exp(-x),0) } n &lt;- 10000 c = 1/exp(1) out1 &lt;- rejection_sampling_unit(px, n, c, 0, 10) tb1 &lt;- out1$data tb1 %&gt;% ggplot(mapping = aes(x = x)) + geom_point(mapping = aes(y = z, color = d, shape=d), size = 0.5) + geom_line(aes(y = y)) + geom_line(aes(y = c), linetype = 7)+ labs(x=&quot;z&quot;,y=NULL,color=&quot;acceptance&quot;,shape = &quot;acceptance&quot;)+ scale_shape_manual(values = c(20,8))+ ggtitle(paste(&quot;以均匀分布作提议分布的拒绝采样，接受率=&quot;,mean(tb1$d),sep = &quot;&quot;)) 接受率比较低，效率不高。 方法2：利用指数分布作提议分布。注意到\\(X\\sim\\mathrm{Gamma}(2,1)\\)，\\(EX=2\\)，使用期望为\\(1\\)的指数分布\\(g(x)=0.5e^{-0.5x}\\)作为提议分布。 # 提议分布为均匀分布 # px为密度函数, # n不是生成px的样本数，而是提议分布的样本数 rejection_sampling_exp &lt;- function(px, n,...){ x &lt;- rexp(n, ...) # 生成n个随机数 y &lt;- px(x) gx &lt;- dexp(x, ...) ppx &lt;- max(y/gx)*gx # 求c z &lt;- runif(n, 0, ppx) d &lt;- (z&lt;=y) output &lt;- list(data = tibble(x,y,z,d,ppx), samples = x[d]) return(output) } px &lt;- function(x){ y &lt;- ifelse(x&gt;0,x*exp(-x),0) } n &lt;- 5000 out1 &lt;- rejection_sampling_exp(px, n, 0.5) tb1 &lt;- out1$data tb1 %&gt;% ggplot(mapping = aes(x = x)) + geom_point(mapping = aes(y = z, color = d, shape=d), size = 0.5) + geom_line(aes(y = y)) + geom_line(aes(y = ppx), linetype = 7)+ labs(x=&quot;z&quot;,y=NULL,color=&quot;acceptance&quot;,shape = &quot;acceptance&quot;)+ scale_shape_manual(values = c(20,8))+ ggtitle(paste(&quot;以指数分布作提议分布的拒绝采样，接受率=&quot;,mean(tb1$d),sep = &quot;&quot;)) 接受率提高了很多。 习题13 解： 设 \\[ P\\{Z=1\\}=0.3,P\\{Z=2\\}=0.3,P\\{Z=3\\}=0.26,P\\{Z=4\\}=0.14 \\] 当\\(Z=1\\)，X均匀取\\(1,2,3,4,5\\)，当\\(Z=2\\)，X均匀取\\(6,9\\)，当\\(Z=3\\)，X均匀取\\(7,10\\)，当\\(Z=4\\)，X均匀取\\(8\\). rng.13 &lt;- function(n) { z &lt;- sample.int(4, n, replace = TRUE, prob = c(0.3,0.3,0.26,0.14)) x &lt;- vector(&quot;integer&quot;,n) x[z==1] &lt;- sample(1:5,sum(z==1),replace = TRUE) x[z==2] &lt;- sample(c(6,9),sum(z==2),replace = TRUE) x[z==3] &lt;- sample(c(7,10),sum(z==3),replace = TRUE) x[z==4] &lt;- 8 x } # 测试 n &lt;- 10000 x &lt;- rng.13(n) table(x)/n #&gt; x #&gt; 1 2 3 4 5 6 7 8 9 10 #&gt; 0.0613 0.0590 0.0602 0.0585 0.0589 0.1507 0.1245 0.1407 0.1510 0.1352 大致符合。 习题14 解： 似乎有点问题。 \\[ F(k)=P\\{X\\le k\\}=\\sum_{i=1}^kP\\{X=i\\}=\\frac32-\\frac{1}{2^{k+1}}-\\frac{2^k}{3^k}\\rightarrow \\frac32\\ne 1 \\] 习题15 解： 1、逆变换法： 先求分布函数： \\[ F(x)= \\begin{cases} \\frac12 e^x &amp; x\\le 0\\\\ 1-\\frac12 e^{-x} &amp; x&gt;0\\\\ \\end{cases} \\] 求逆函数可以得到： \\[ X= \\begin{cases} \\log(2u) &amp; u\\le 0.5\\\\ -\\log(2(1-u)) &amp; u&gt;0.5 \\end{cases} \\] 采样函数： rng.15.1 &lt;- function(n) { u &lt;- runif(n) x &lt;- ifelse(u&lt;=0.5,log(2*u),-log(2-2*u)) x } # 测试 n &lt;- 10000 x &lt;- rng.15.1(n) hist(x,breaks = 100,freq = FALSE,ylim=c(0,0.5)) curve(0.5*exp(-abs(x)),from = -10,to =10,add = TRUE,col=&quot;red&quot;) 2、复合法 实际上类似于上面的逆变换法，设 \\[ P\\{Z=0\\}=P\\{Z=1\\}=0.5 \\] 当\\(Z=0\\)，取\\(X=\\log u\\)，当\\(Z=1\\)，取\\(X=-\\log u\\)。 采样函数： rng.15.2 &lt;- function(n) { z &lt;- runif(n) u &lt;- runif(n) x &lt;- log(u) x &lt;- ifelse(z&lt;=0.5,x,-x) x } # 测试 n &lt;- 10000 x &lt;- rng.15.2(n) hist(x,breaks = 100,freq = FALSE,ylim=c(0,0.5)) curve(0.5*exp(-abs(x)),from = -10,to =10,add = TRUE,col=&quot;red&quot;) 习题16 解： 比较容易想到的当然是拒绝采样。 先观察密度函数形状： curve(x*(1-x)^3/0.000336,0.8,1,ylab=&quot;p(x)&quot;) 使用均匀分布作提议分布拒绝率应该会在0.5以下，不妨考虑一下\\([0.8,1]\\)上的三角分布： \\[ p(x) = 50-50x,\\qquad 0.8&lt;x&lt;1 \\] 其分布函数的逆为： \\[ F^{-1}(u) = 1-\\frac{\\sqrt{u}}{5} \\] # 提议分布为三角分布 # px为密度函数, # n不是生成px的样本数，而是提议分布的样本数 rejection_sampling_tri &lt;- function(px, n){ x &lt;- 1-sqrt(runif(n))/5 # 生成n个随机数 y &lt;-px(x) # 提议分布 ppx &lt;- (px(1)-px(0.8))/0.2*(x-0.8)+px(0.8) z &lt;- runif(n,0,ppx) d &lt;- (z&lt;=y) output &lt;- list(data = tibble(x,y,ppx,z,d), samples = x[d]) return(output) } px &lt;- function(x){ x*(1-x)^3/0.000336 } n &lt;- 10000 out1 &lt;- rejection_sampling_tri(px, n) tb1 &lt;- out1$data tb1 %&gt;% ggplot(mapping = aes(x = x)) + geom_point(mapping = aes(y = z, color = d, shape=d), size = 0.5) + geom_line(aes(y = y)) + geom_line(aes(y = ppx), linetype = 7)+ labs(x=&quot;z&quot;,y=NULL,color=&quot;acceptance&quot;,shape = &quot;acceptance&quot;)+ scale_shape_manual(values = c(20,8))+ ggtitle(paste(&quot;以三角分布作提议分布的拒绝采样，接受率=&quot;,mean(tb1$d),sep = &quot;&quot;)) 还有另一个方法是，注意到这是一个条件\\(\\mathrm{Beta}(2,4)\\)分布，即 \\[ p(x) = p(y|y&gt;0.8),\\quad y\\sim \\mathrm{Beta}(2,4) \\] 所以另一个办法就是生成\\(\\mathrm{Beta}(2,4)\\)分布随机数，若大于\\(0.8\\)就保留： # n：试投点数 rng.16.2 &lt;- function(n) { x &lt;- rbeta(n,2,4) x[x&gt;0.8] } # 测试 n &lt;- 100000 x &lt;- rng.16.2(n) hist(x,freq = FALSE) curve(x*(1-x)^3/0.000336,0.8,1,add = TRUE,col=&quot;red&quot;) length(x)/n #&gt; [1] 0.00635 但是拒绝率太低了，惨不忍睹。 习题17 解： 只证前半部分。 把\\(Y\\)看作\\(X\\)的一个变换，\\(Y=g(X)=a+(b-a)X\\)，\\(X\\)有密度函数\\(p_R(x)=2x,x\\in(0,1)\\)，函数\\(g(\\cdot)\\)有反函数\\(x=g^{-1}(y)=h(y)=(y-a)/(b-a)\\)，则\\(Y\\)有密度函数： \\[ p_Y(x) = p_R(h(y))\\cdot|h&#39;(y)|=2\\cdot\\frac{y-a}{b-a}\\cdot\\frac1{b-a}=\\frac{2(y-a)}{(b-a)^2},\\quad y\\in(a,b) \\] 故\\(Y\\sim\\mathrm{RT}(a,b)\\). 类似地，令\\(Y=g(X)=1-X\\)，\\(h(y)=1-y\\)，则\\(Y\\)有密度函数 \\[ p_Y(x) = p_R(h(y))\\cdot|h&#39;(y)|=2(1-y)\\cdot|-1|=2(1-y),\\quad y\\in(0,1) \\] 故\\(Y\\sim\\mathrm{LT}(0,1)\\). \\(X\\)的分布函数 \\[ F(x)=P\\{X\\le x\\}=P\\{U_1\\le x,U_2\\le x\\}=P\\{U_1\\le x\\}P\\{U_2\\le x\\}=x^2,\\quad x\\in (0,1) \\] 故\\(X\\sim\\mathrm{RT}(0,1)\\). 习题18 解： 只需要证明它是变形的Box-Muller变换即可。 由于\\(\\alpha\\sim U(0,1)\\)，则\\(\\tilde\\alpha=\\alpha/2\\pi\\sim U(0,1)\\). 由于\\(R\\sim\\exp(1/2)\\)，则\\(1-e^{-R/2}\\sim U(0,1)\\)，即\\(\\tilde R=e^{-R/2}\\sim U(0,1)\\). 并且还有\\(\\alpha\\perp\\!\\!\\!\\!\\perp R\\)，所以\\(\\tilde\\alpha\\perp\\!\\!\\!\\!\\perp \\tilde R\\)，利用Box-Muller公式，有 \\[ \\begin{cases} X = \\sqrt{-2\\ln\\tilde R}\\cos\\left(\\frac{\\alpha}{2\\pi}\\cdot 2\\pi\\right)\\\\ Y = \\sqrt{-2\\ln\\tilde R}\\sin\\left(\\frac{\\alpha}{2\\pi}\\cdot 2\\pi\\right) \\end{cases} \\] 相互独立且都服从标准正态分布。 习题20 解： 容易知道，联合分布的密度函数为\\(p(x,y)=1/\\pi\\)。 （1）\\(R^2\\)的分布函数： \\[ F_1(r^2)=P\\{R^2\\le r^2\\}=\\int_{x^2+y^2\\le r^2} p(x,y)\\mathrm dx\\mathrm dy=r^2 \\] 从而\\(R^2\\sim U(0,1)\\)。 （2）不妨用\\(A(\\theta,R^2)\\)表示圆\\(x^2+y^2\\le R^2\\)中弧度为\\(\\theta\\)的扇形区域，则\\(\\theta\\)的分布函数： \\[ F_2(z)=P\\{\\theta\\le z\\}=\\int_{A(z,1)} p(x,y)\\mathrm dx\\mathrm dy=\\frac z{2\\pi} \\] 从而\\(\\theta\\sim U(0,2\\pi)\\)。 （3）\\((R^2,\\theta)\\)的联合分布函数： \\[ F(r^2,z)=P\\{R^2\\le r^2,\\theta\\le z\\}=\\int_{A(z,r^2)} p(x,y)\\mathrm dx\\mathrm dy=r^2\\cdot\\frac{z}{2\\pi}=F_1(r^2)\\cdot F_2(z) \\] 从而两者独立。 习题21 解： 1、由于 \\[ F(x)=\\frac{G(x)-G(a)}{G(b)-G(a)}=\\frac{P\\{a&lt;X\\le x\\}}{P\\{a&lt;X\\le b\\}}=P\\{X\\le x|a&lt;X\\le b\\} \\] 2、这不是显然吗…（嚣张doge）。 习题22 解： 1、\\(p_1=\\lambda_1\\)显然，不妨记\\(S_n=\\sum_{k=1}^np_k\\)，由于 \\[ 1-\\lambda_n=\\frac{1-S_n}{1-S_{n-1}} \\] 则 \\[ (1-\\lambda_1)\\cdots(1-\\lambda_{n-1})\\lambda_n=(1-p_1)\\frac{1-S_2}{1-S_{1}}\\cdot\\frac{1-S_3}{1-S_{2}}\\cdots\\frac{1-S_{n-1}}{1-S_{n-2}}\\frac{p_n}{1-S_{n-1}}=p_n \\] 2、由算法过程可以知道，取\\(X=k\\)当且仅当前\\(k-1\\)个\\((0,1)\\)均匀随机数大于等于对应的\\(\\lambda_i\\)，并且第\\(k\\)个\\((0,1)\\)均匀随机数小于\\(\\lambda_k\\)。而第\\(i\\)个\\((0,1)\\)均匀随机数大于\\(\\lambda_i\\)的概率为\\(p_i=1-\\lambda_i\\)，从而取\\(X=k\\)的概率为 \\[ p=p_1\\cdot p_2\\cdots p_{k-1}(1-p_k)=(1-\\lambda_1)\\cdots(1-\\lambda_{k-1})\\lambda_k=p_k \\] 从而算法是合理的。 3、上述算法不就是生成\\(X\\)分布的随机数吗…明显的有效性？大概是一个几何分布的“无记忆性”，\\(\\lambda_k\\)是一个常数，当生成随机数数量较大时也很有效，因为不需要计算所有的\\(\\lambda_k\\)。 习题23 解： 1、几何分布，\\(p=\\lambda\\)。 2、… "],["rng-multi.html", "6 随机向量和随机过程的随机数 6.1 笔记 6.2 习题", " 6 随机向量和随机过程的随机数 6.1 笔记 将书上的一些函数例子自己重新实现一遍。 6.1.1 多项分布随机数 利用条件分布的方法： # 输入 # n: 输出随机数个数 # m: 独立试验次数 # prob: 每次使用出现结果概率 # 输出 # n行r列，r为每次试验可能出现的结果个数 rng.multinom &lt;- function(n, m, prob) { r &lt;- length(prob) pp &lt;- cumsum(prob[-r]) # 预先计算二项分布各p值 pp &lt;- prob[-1]/(1-pp) res &lt;- matrix(0,n,r) # 输出结果 mr &lt;- m # 按列循环 for(j in seq(r)) { if(j==1) res[,1] &lt;- rbinom(n,m,prob[[1]]) else{ mr &lt;- mr-res[,j-1] res[,j] &lt;- rbinom(n,mr,pp[j-1]) } } res } 测试： prob &lt;- c(0.1, 0.3, 0.6) x &lt;- rng.multinom(100000, 5, prob) # (1,2,2)的理论概率： p122 &lt;- 30*prod(prob^c(1,2,2)); p122 #&gt; [1] 0.0972 # 模拟结果 mean(x[,1]==1 &amp; x[,2]==2 &amp; x[,3]==2) #&gt; [1] 0.09752 # (1,1,3)的理论概率： p113 &lt;- 20*prod(prob^c(1,1,3)); p113 #&gt; [1] 0.1296 # 模拟结果 mean(x[,1]==1 &amp; x[,2]==1 &amp; x[,3]==3) #&gt; [1] 0.12853 6.1.2 多元正态分布模拟 利用对协方差矩阵的Cholesky分解。 # 输入 # n: 生成随机数个数 # mu: 均值向量 # Sigma: 协方差矩阵 # 输出 # n行m列矩阵，m为维数 rng.mnorm &lt;- function(n, mu, Sigma) { m &lt;- length(mu) M &lt;- chol(Sigma) # Sigma = M&#39; M y &lt;- matrix(rnorm(n*m),n,m)%*%M x &lt;- mu+t(y) t(x) } 测试： x &lt;- rng.mnorm(1000, c(3,2), rbind(c(4, 1), c(1, 1))) plot(x[,1], x[,2], type=&quot;p&quot;, cex=0.1) abline(v=3, h=2, col=&quot;green&quot;) var(x) #&gt; [,1] [,2] #&gt; [1,] 3.8500295 0.9318417 #&gt; [2,] 0.9318417 0.9670824 6.2 习题 习题1 # 输入： # n: 生成随机数个数 # ni: 各个颜色球的个数向量 # m: 总共抽取的球个数 # 输出 # n行r列矩阵，其中r为球的颜色数量 rng.hyper &lt;- function(n,ni,m) { r &lt;- length(ni) N &lt;- sum(ni) # 总球数 N &lt;- N-cumsum(ni) x &lt;- matrix(0,n,r) xr &lt;- rep(0,n) # 按列循环 for(j in seq(r)) { if(j==1) x[,1] &lt;- rhyper(n,ni[[1]],N[[1]],m) else{ xr &lt;- xr + x[,j-1] x[,j] &lt;- rhyper(n,ni[[j]],N[[j]],m-xr) } } x } 测试： n &lt;- 10000 ni &lt;- c(20,30,50) m &lt;- 10 x &lt;- rng.hyper(n,ni,m) apply(x,2,sum)/n/10 #&gt; [1] 0.20152 0.30026 0.49822 接下来采用试验计数的方法验证一下上面定义的函数： trial.hyper &lt;- function(n,ni,m) { r &lt;- length(ni) x &lt;- matrix(0,n,r) s &lt;- rep(1:r,times = ni) # 样本数据 for(i in seq(n)) { y &lt;- sample(s,m,replace = FALSE) # 不放回抽样 y &lt;- factor(y,levels=(1:r)) t &lt;- table(y) #计数 x[i,] &lt;- as.integer(t) } x } # 测试 n &lt;- 10000 ni &lt;- c(20,30,50) m &lt;- 10 x &lt;- trial.hyper(n,ni,m) apply(x,2,sum)/n/10 #&gt; [1] 0.19965 0.29942 0.50093 非常接近，定义的函数应该是可行的。 "],["sim-ranquad.html", "7 随机模拟积分 7.1 习题", " 7 随机模拟积分 7.1 习题 习题1 利用恒等式\\(EK=\\sum_{n=0}^{\\infty} P\\{K&gt;n\\}\\)。 不难得到，\\(P\\{K&gt;n\\}=P\\{\\sum_{i=1}^n U_i&lt;1\\}\\)，\\(U_i\\)iid标准均匀分布，这涉及到标准均匀分布随机数之和的分布，学名为Irwin-Hall分布，我们不妨设\\(X_n=\\sum_{i=1}^n U_i\\)，其密度函数为\\(f_n(x)\\)，由Irwin-Hall分布可以知道， \\[ P\\{K&gt;n\\}=P\\{\\sum_{i=1}^n U_i&lt;1\\}=\\int_0^1 f_n(x)\\mathrm dx=\\frac1{n!} \\] 再利用恒等式\\(EK=\\sum_{n=0}^{\\infty} P\\{K&gt;n\\}=\\sum_{n=0}^{\\infty} \\frac1{n!}=e\\) 定义函数 sampling_K &lt;- function(n) { k &lt;- 10 # 期望多少个均匀分布随机数之和能大于1 U &lt;- runif(k*n) U &lt;- matrix(U,n,k) S &lt;- t(apply(U,1,cumsum)) x &lt;- vector(&quot;integer&quot;,n) # 按行循环 for(i in seq_along(x)){ j &lt;- match(TRUE,S[i,]&gt;1,nomatch = -1) # 匹配失败 if(j==-1){ jj &lt;- 0 while(j!=-1){ u &lt;- cumsum(runif(k)) j &lt;- match(TRUE,u&gt;1,nomatch = -1) jj &lt;- jj+1 } x[[i]] &lt;- jj*k+j } # 匹配成功 else{ x[[i]] &lt;- j } } list(x=x,S=S) } 测试一下： sampling_K(10) #&gt; $x #&gt; [1] 4 2 5 3 2 3 2 2 2 2 #&gt; #&gt; $S #&gt; [,1] [,2] [,3] [,4] [,5] [,6] [,7] #&gt; [1,] 0.21808916 0.2357843 0.2658886 1.2296056 1.592953 1.887922 2.140974 #&gt; [2,] 0.98763424 1.9464288 2.3330987 2.9809780 3.850568 4.545099 4.878368 #&gt; [3,] 0.34846189 0.6999084 0.8075462 0.9006072 1.690359 2.342677 2.983584 #&gt; [4,] 0.38104699 0.8358012 1.3227212 2.1230489 3.029562 3.403099 3.458583 #&gt; [5,] 0.02098596 1.0019890 1.8790498 2.2702906 3.216077 4.026435 4.870650 #&gt; [6,] 0.74972687 0.9305819 1.6982691 2.4187291 2.497471 2.874808 3.553516 #&gt; [7,] 0.16295804 1.0107804 1.5122450 1.7406904 2.666825 2.871587 3.278336 #&gt; [8,] 0.31904129 1.1742926 1.4711369 2.3982398 2.572193 3.375264 3.975827 #&gt; [9,] 0.59789026 1.2797888 1.7417666 1.8840650 2.333020 3.101203 4.013269 #&gt; [10,] 0.58799732 1.0799603 1.6595000 2.0488883 3.037629 3.134606 3.559394 #&gt; [,8] [,9] [,10] #&gt; [1,] 2.535080 2.973997 3.701060 #&gt; [2,] 5.344494 5.515443 5.869804 #&gt; [3,] 3.829691 4.718623 5.003419 #&gt; [4,] 3.758749 4.060928 4.226667 #&gt; [5,] 5.260501 5.512067 5.698450 #&gt; [6,] 4.420283 4.758983 5.289225 #&gt; [7,] 3.546575 3.659780 3.665562 #&gt; [8,] 4.769557 5.550969 5.796674 #&gt; [9,] 4.322063 5.169168 5.891357 #&gt; [10,] 3.672081 4.365124 4.733642 估计e： n &lt;- 100000 x &lt;- sampling_K(n)$x e &lt;- mean(x) e #&gt; [1] 2.71649 直接用R求标准差： sd(x) #&gt; [1] 0.8748941 95%置信区间为\\(\\hat\\theta \\pm 2 \\frac{S_N}{ \\sqrt{N}}\\)： d &lt;- sd(x)/sqrt(n) cat(&quot;95%置信区间为(&quot;,e-d,&quot;,&quot;,e+d,&quot;)&quot;,sep = &quot;&quot;) #&gt; 95%置信区间为(2.713723,2.719257) 习题2 容易知道： \\[ P\\{M&gt;n\\} = P\\{U_1\\le U_2\\le\\cdots\\le U_n\\} \\] 由于\\(U_i\\overset{iid}{\\sim}U(0,1)\\)，记事件集合\\(A=\\{U_{i_1}\\le U_{i_2}\\le\\cdots\\le U_{i_n},i_1,\\cdots,i_n\\text{是}1,\\cdots,n\\text{的一个排列}\\}\\)，则\\((U_1,\\cdots,U_n)\\)在集合\\(A\\)上均匀分布，从而 \\[ P\\{M&gt;n\\} = P\\{U_1\\le U_2\\le\\cdots\\le U_n\\}=\\frac1{n!} \\] 显然、易证。 定义函数： sampling_M &lt;- function(n) { k &lt;- 10 # 期望值 U &lt;- runif(k*n) U &lt;- matrix(U,n,k) S &lt;- U[,1:(k-1)]&gt;U[,2:k] x &lt;- vector(&quot;integer&quot;,n) # 按行循环 for(i in seq_along(x)){ j &lt;- match(TRUE,S[i,],nomatch = -1) # 匹配失败 if(j==-1){ jj &lt;- 0 while(j!=-1){ u &lt;- runif(k) u &lt;- u[1:(k-1)]&gt;u[2:k] j &lt;- match(TRUE,u,nomatch = -1) jj &lt;- jj+1 } x[[i]] &lt;- jj*k+j+1 } # 匹配成功 else{ x[[i]] &lt;- j+1 } } list(x=x,S=S) } 测试一下： sampling_M(10) #&gt; $x #&gt; [1] 3 2 2 3 3 2 3 2 3 2 #&gt; #&gt; $S #&gt; [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] #&gt; [1,] FALSE TRUE TRUE FALSE TRUE FALSE FALSE FALSE TRUE #&gt; [2,] TRUE FALSE FALSE TRUE TRUE FALSE TRUE TRUE FALSE #&gt; [3,] TRUE FALSE FALSE TRUE FALSE TRUE FALSE FALSE TRUE #&gt; [4,] FALSE TRUE FALSE TRUE FALSE FALSE TRUE FALSE TRUE #&gt; [5,] FALSE TRUE FALSE FALSE TRUE FALSE TRUE FALSE TRUE #&gt; [6,] TRUE FALSE FALSE TRUE FALSE TRUE TRUE FALSE TRUE #&gt; [7,] FALSE TRUE TRUE FALSE TRUE FALSE TRUE FALSE FALSE #&gt; [8,] TRUE TRUE FALSE TRUE FALSE TRUE FALSE TRUE FALSE #&gt; [9,] FALSE TRUE TRUE TRUE FALSE TRUE TRUE TRUE FALSE #&gt; [10,] TRUE TRUE TRUE FALSE TRUE FALSE TRUE FALSE TRUE 估计e： n &lt;- 100000 x &lt;- sampling_M(n)$x e &lt;- mean(x) e #&gt; [1] 2.71777 d &lt;- sd(x)/sqrt(n) cat(&quot;估计的标准差：&quot;, sd(x), &quot;，近似95%的置信区间：(&quot;, e-d,&quot;,&quot;, e+d,&quot;)&quot;, sep=&quot;&quot;) #&gt; 估计的标准差：0.8767234，近似95%的置信区间：(2.714998,2.720542) "],["sim-impsamp.html", "8 重要抽样法 8.1 笔记 8.2 习题", " 8 重要抽样法 8.1 笔记 对部分例子自编码实现 8.1.1 例12.1 用随机投点、平均值法、重要抽样法计算\\(I=\\int_0^1e^x\\mathrm dx=e-1\\)，比较它们的精度 随机投点法 以\\([0,1]\\times[0,e]\\)作为矩形投点。 N &lt;- 10000 x &lt;- runif(N) y &lt;- runif(N,0,exp(1)) phat &lt;- mean(y&lt;=exp(x)) I1.est &lt;- exp(1)*phat # 估计 I.true &lt;- exp(1)-1 # 准确值 var1 &lt;- exp(2)*phat*(1-phat) # 渐进方差 ## 定义函数用于求各种误差 # 输入：估计值I1.est，准确值I.true，序列方差var1 I.err &lt;- function(I1.est,I.true,var1,N){ ae1 &lt;- abs(I1.est-I.true) # 绝对误差 re1 &lt;- ae1/I.true # 相对误差 mre1 &lt;- 0.8*sqrt(var1/N)/I1.est # MRE I1 &lt;- list(estimation = I1.est,AE = ae1,RE = re1,VAE = var1,MRE = mre1) I1 } I1 &lt;- I.err(I1.est,I.true,var1,N) I1 #&gt; $estimation #&gt; [1] 1.710343 #&gt; #&gt; $AE #&gt; [1] 0.007938902 #&gt; #&gt; $RE #&gt; [1] 0.004620256 #&gt; #&gt; $VAE #&gt; [1] 1.723921 #&gt; #&gt; $MRE #&gt; [1] 0.006141373 8.1.2 平均值法 N &lt;- 10000 u &lt;- exp(runif(N)) I2.est &lt;- mean(u) # 估计 var2 &lt;- var(u) # 渐进方差 I2 &lt;- I.err(I2.est,I.true,var2,N) I2 #&gt; $estimation #&gt; [1] 1.705871 #&gt; #&gt; $AE #&gt; [1] 0.01241085 #&gt; #&gt; $RE #&gt; [1] 0.007222825 #&gt; #&gt; $VAE #&gt; [1] 0.2395786 #&gt; #&gt; $MRE #&gt; [1] 0.00229545 8.1.3 重要采样法 取提议分布为\\(g(x)=\\frac23(1+x)\\) N &lt;- 10000 u &lt;- runif(N) x &lt;- sqrt(1+3*u)-1 y &lt;- 1.5*exp(x)/(1+x) I3.est &lt;- mean(y) # 估计 var3 &lt;- var(y) # 渐进方差 I3 &lt;- I.err(I3.est,I.true,var3,N) I3 #&gt; $estimation #&gt; [1] 1.717555 #&gt; #&gt; $AE #&gt; [1] 0.0007270307 #&gt; #&gt; $RE #&gt; [1] 0.0004231149 #&gt; #&gt; $VAE #&gt; [1] 0.02692227 #&gt; #&gt; $MRE #&gt; [1] 0.0007642496 8.1.4 比较 knitr::kable(rbind(I1,I2,I3)) estimation AE RE VAE MRE I1 1.71034292646643 0.00793890199261393 0.00462025603781979 1.72392117133341 0.00614137324650025 I2 1.70587097871559 0.0124108497434559 0.00722282546314646 0.239578602089725 0.00229544990572984 I3 1.71755479775617 0.000727030702871501 0.000423114934250048 0.0269222685573592 0.000764249584277972 可以看到，重要抽样法得到的\\(I_3\\)在精度上要高于前两种方法。 8.2 习题 习题1 理论推导： \\[ \\begin{align} I=Eh(X)&amp;=\\int_{-\\infty}^{+\\infty}h(x)p(x)\\mathrm dx\\\\ &amp;= \\int_{-\\infty}^{+\\infty}\\left[\\exp(-\\frac12 (x-3)^2) + \\exp(-\\frac12 (x-6)^2)\\right]\\frac1{\\sqrt{2\\pi}}e^{\\frac{x^2}2}\\mathrm dx\\\\ &amp;= \\frac{e^{-9/4}}{\\sqrt{2}}\\int_{-\\infty}^{+\\infty}\\mathcal N(\\frac32,\\frac12)\\mathrm dx+\\frac{e^{-9}}{\\sqrt{2}}\\int_{-\\infty}^{+\\infty}\\mathcal N(3,\\frac12)\\mathrm dx\\\\ &amp;= \\frac{e^{-9/4}+e^{-9}}{\\sqrt{2}} \\end{align} \\] 大约为： I.true &lt;- (exp(-9/4)+exp(-9))/sqrt(2);I.true #&gt; [1] 0.07461577 平均值法： N &lt;- 1000 X &lt;- rnorm(N) fun_h &lt;- function(x){ exp(-(x-3)^2/2)+exp(-(x-6)^2/2) } eta &lt;- fun_h(X) I1.est &lt;- mean(eta) var1 &lt;- var(eta) I1 &lt;- I.err(I1.est,I.true,var1,N) I1 #&gt; $estimation #&gt; [1] 0.06876503 #&gt; #&gt; $AE #&gt; [1] 0.005850737 #&gt; #&gt; $RE #&gt; [1] 0.07841153 #&gt; #&gt; $VAE #&gt; [1] 0.01951712 #&gt; #&gt; $MRE #&gt; [1] 0.0513961 重要抽样法： 不妨取试投密度函数为: \\[ g(x)=\\frac12\\mathcal N(3,1)+\\frac12\\mathcal N(6,1) \\] 由于： \\[ Eh(X)=\\int_{-\\infty}^{+\\infty}h(x)p(x)\\mathrm dx=\\int_{-\\infty}^{+\\infty}h(x)\\frac{p(x)}{g(x)}g(x)\\mathrm dx \\] 所以一种重要性采样方法是，先从\\(g(x)\\)中分别采样\\(N\\)个样本\\(X_i\\)，求得其重要性权重为\\(p(X_i)/g(X_i)\\)，再对\\(h(X_i)\\)求加权均值即可。 N &lt;- 1000 u &lt;- runif(N) X &lt;- rnorm(N,3,1) X[u&gt;0.5] &lt;- X[u&gt;0.5]+3 # N(6,1) fun_g &lt;- function(x){ 0.5*dnorm(x,3,1)+0.5*dnorm(x,6,1) } W &lt;- dnorm(X)/fun_g(X) # 重要性权重 eta &lt;- W*fun_h(X) I2.est &lt;- mean(eta) var2 &lt;- var(eta) I2 &lt;- I.err(I2.est,I.true,var2,N) I2 #&gt; $estimation #&gt; [1] 0.06912794 #&gt; #&gt; $AE #&gt; [1] 0.005487829 #&gt; #&gt; $RE #&gt; [1] 0.07354784 #&gt; #&gt; $VAE #&gt; [1] 0.0402366 #&gt; #&gt; $MRE #&gt; [1] 0.07340861 看一下试投密度函数跟\\(h(x)\\)的匹配度： curve(fun_h,0,10) curve(fun_g,0,10,add = TRUE,col=&quot;red&quot;) 两种方法的误差比较： knitr::kable(rbind(I1,I2)) estimation AE RE VAE MRE I1 0.0687650335104724 0.00585073681836018 0.0784115314038294 0.0195171153540842 0.0513960972874723 I2 0.0691279414866747 0.0054878288421579 0.073547841400993 0.0402365959364118 0.0734086062178863 习题2 每轮生成\\(N\\)个随机数，生成\\(n\\)轮： # 估计概率 N &lt;- 10^6 n &lt;- 100 X &lt;- matrix(rnorm(N*n),n,N)&gt;4.5 m &lt;- apply(X,1,mean) m &lt;- mean(m);m #&gt; [1] 3.58e-06 估计概率大概是\\(3.58\\times 10^{-6}\\) fun &lt;- function(x) match(TRUE,x); ma &lt;- apply(X,1,fun) ma &lt;- mean(ma,na.rm = TRUE);ma #&gt; [1] 283180.7 平均\\(2.831807\\times 10^{5}\\)个样本点中才能有一个样本点满足要求。 此时的试投密度函数实际上是： \\[ g(x) = e^{-(x-4.5)}, \\qquad x&gt;4.5 \\] N &lt;- 1000 # 生成g(x)样本 X &lt;- rexp(N,1)+4.5 eta &lt;- dnorm(X)/exp(-X+4.5) I.est &lt;- mean(eta) I.true &lt;- pnorm(4.5,lower.tail = FALSE) var &lt;- var(eta) I &lt;- I.err(I.est,I.true,var,N) I #&gt; $estimation #&gt; [1] 3.536576e-06 #&gt; #&gt; $AE #&gt; [1] 1.389028e-07 #&gt; #&gt; $RE #&gt; [1] 0.04088175 #&gt; #&gt; $VAE #&gt; [1] 2.06534e-11 #&gt; #&gt; $MRE #&gt; [1] 0.03250893 效率提高太大了。 习题3 略。 "],["sim-stratsamp.html", "9 分层抽样法 9.1 习题", " 9 分层抽样法 library(tidyverse) 9.1 习题 习题1 利用拉格朗日乘子法。记 \\[ g(\\alpha_1,\\cdots,\\alpha_m) = \\alpha_1+\\cdots+\\alpha_m-1\\\\ L(\\alpha_1,\\cdots,\\alpha_m,\\lambda^2) = f(\\alpha_1,\\cdots,\\alpha_m)+\\lambda^2 g(\\alpha_1,\\cdots,\\alpha_m) \\] 令： \\[ \\frac{\\partial L}{\\partial \\alpha_i}=-\\frac{\\sigma_i^2}{\\alpha_i^2}+\\lambda^2=0\\\\ \\frac{\\partial L}{\\partial \\lambda} = \\alpha_1+\\cdots+\\alpha_m-1=0 \\] 可以得到： \\[ \\lambda = \\frac{\\sigma_i}{\\alpha_i} \\] 则： \\[ \\alpha_1+\\cdots+\\alpha_m = \\frac{\\sigma_1+\\cdots+\\sigma_m}{\\lambda} \\] 可以解得 \\[ \\lambda = \\sigma_1+\\cdots+\\sigma_m \\] 从而： \\[ \\alpha_i=\\frac{\\sigma_i}{\\sum_{k=1}^m\\sigma_k},i=1,\\cdots,m \\] 可以验证这是最小值点。 习题2 先看一下准确值： I.true &lt;- exp(1)-exp(-1);I.true #&gt; [1] 2.350402 随机投点法：在矩形\\([-1,1]\\times[0,e]\\)内随机投点 # 随机投点法 # 输入：试投点数，随机种子（默认为1） # 输出：积分估计值 method.1 &lt;- function(N, seed=1) { set.seed(seed) x &lt;- runif(N,-1,1) y &lt;- runif(N,0,exp(1)) I &lt;- 2*exp(1)*mean(y&lt;=exp(x)) I } # 测试 N &lt;- 10000 I1.est &lt;- method.1(N);I1.est #&gt; [1] 2.375778 平均值法： method.2 &lt;- function(N, seed=1) { set.seed(seed) u &lt;- runif(N,-1,1) I &lt;- 2*mean(exp(u)) I } # 测试 N &lt;- 10000 I2.est &lt;- method.2(N);I2.est #&gt; [1] 2.35767 重要抽样法：可以利用梯形分布，取试投密度为 \\[ g(x)=e^{-1}x+0.5,\\quad x\\in [-1,1] \\] 为得到服从\\(g(x)\\)的样本，可以生成标准均匀分布随机数\\(U\\)，再利用变换 \\[ X = -\\frac{e}{2}+\\sqrt{2eU+1-e+\\frac {e^2}{4}} \\] 即可得到\\(g(x)\\)的样本。 其中\\(g(x)\\)跟被积函数的对比如下： curve(exp(x),-1,1,ylim=c(0,3)) curve(exp(-1)*x+0.5,-1,1,add = TRUE,col=&quot;red&quot;) method.3 &lt;- function(N, seed=1) { set.seed(seed) u &lt;- runif(N) x &lt;- -exp(1)/2+sqrt(2*exp(1)*u+1-exp(1)+exp(2)/4) eta &lt;- exp(x)/(exp(-1)*x+0.5) I &lt;- mean(eta) } # 测试 N &lt;- 10000 I3.est &lt;- method.3(N);I3.est #&gt; [1] 2.353182 分层抽样法：这里简单点，分为\\([-1,0],[0,1]\\)两个区间，都使用平均值法： method.4 &lt;- function(N, seed=1) { set.seed(seed) n &lt;- ceiling(N/2) # [-1,0] u &lt;- runif(n,-1,0) I1 &lt;- mean(exp(u)) # [0,1] u &lt;- runif(N-n) I2 &lt;- mean(exp(u)) I1+I2 } # 测试 N &lt;- 10000 I4.est &lt;- method.4(N);I4.est #&gt; [1] 2.354859 四种方法对比一下： df &lt;- data.frame( `准确值` = I.true, `随机投点法` = I1.est, `平均值法` = I2.est, `重要抽样法` = I3.est, `分层抽样法` = I4.est ) knitr::kable(df) 准确值 随机投点法 平均值法 重要抽样法 分层抽样法 2.350402 2.375778 2.35767 2.353182 2.354859 没怎么看懂，先跳过咯 B &lt;- 1000 N &lt;- 10000 seed &lt;- 1:B I1 &lt;- map_dbl(seed,method.1,N=N) var1 &lt;- var(I1) I2 &lt;- map_dbl(seed,method.2,N=N) var2 &lt;- var(I2) I3 &lt;- map_dbl(seed,method.3,N=N) var3 &lt;- var(I3) I4 &lt;- map_dbl(seed,method.4,N=N) var4 &lt;- var(I4) df &lt;- data.frame( `随机投点法` = var1, `平均值法` = var2, `重要抽样法` = var3, `分层抽样法` = var4 ) rownames(df) &lt;- &quot;抽样分布方差估计&quot; knitr::kable(df,row.names = TRUE) 随机投点法 平均值法 重要抽样法 分层抽样法 抽样分布方差估计 0.0006886 0.0001732 1.43e-05 5.43e-05 直接利用3的一些结果： mae1 &lt;- mean(abs(I1-I.true)) mae2 &lt;- mean(abs(I2-I.true)) mae3 &lt;- mean(abs(I3-I.true)) mae4 &lt;- mean(abs(I4-I.true)) df &lt;- data.frame( `随机投点法` = mae1, `平均值法` = mae2, `重要抽样法` = mae3, `分层抽样法` = mae4 ) rownames(df) &lt;- &quot;MAE估计&quot; knitr::kable(df,row.names = TRUE) 随机投点法 平均值法 重要抽样法 分层抽样法 MAE估计 0.0208923 0.0104201 0.0030033 0.005848 重要抽样法&lt;分层平均值抽样法&lt;平均值法&lt;随机投点法。 习题3 先定义函数： fun.h &lt;- function(x) ifelse(x&gt;0&amp;x&lt;1,exp(-x)/(1+x^2),0); fun.f.1 &lt;- function(x) ifelse(x&gt;0&amp;x&lt;1,1,0); fun.f.2 &lt;- function(x) ifelse(x&gt;0,exp(-x),0); fun.f.3 &lt;- function(x) 1/(pi*(1+x^2)); fun.f.4 &lt;- function(x) ifelse(x&gt;0&amp;x&lt;1,exp(-x)/(1-exp(-1)),0); fun.f.5 &lt;- function(x) ifelse(x&gt;0&amp;x&lt;1,4/(pi*(1+x^2)),0); ## 绘图 ggplot()+ xlim(0,1)+ geom_function(fun=fun.h,aes(color=&quot;fun.h&quot;))+ geom_function(fun=fun.f.1,aes(color=&quot;fun.f.1&quot;))+ geom_function(fun=fun.f.2,aes(color=&quot;fun.f.2&quot;))+ geom_function(fun=fun.f.3,aes(color=&quot;fun.f.3&quot;))+ geom_function(fun=fun.f.4,aes(color=&quot;fun.f.4&quot;))+ geom_function(fun=fun.f.5,aes(color=&quot;fun.f.5&quot;)) \\(I_1\\)的估计实际上是平均值法： N &lt;- 10000 # I1 u &lt;- runif(N) eta &lt;- fun.h(u) I1 &lt;- mean(eta);I1 #&gt; [1] 0.5252989 var1 &lt;- var(eta)/N \\(I_2\\)需要生成\\(e^{-x}\\)的样本，再判断是否在\\((0,1)\\)内，满足就保留，再进行重要性采样。 # I2 x &lt;- rexp(2*N) x &lt;- x[x&gt;0&amp;x&lt;1] n &lt;- length(x);n #&gt; [1] 12675 x &lt;- x[1:N] eta &lt;- n/2/N/(1+x^2) I2 &lt;- mean(eta);I2 #&gt; [1] 0.5260915 var2 &lt;- var(eta)/N \\(f_3(x)\\)是柯西分布，先生成柯西分布随机数，再判断是否在\\((0,1)\\)内，满足就保留，再进行重要性采样。 # I3 x &lt;- rcauchy(5*N) x &lt;- x[x&gt;0 &amp; x&lt;1] n &lt;- length(x);n #&gt; [1] 12351 x &lt;- x[1:N] eta &lt;- pi*exp(-x)*n/5/N I3 &lt;- mean(eta);I3 #&gt; [1] 0.5182761 var3 &lt;- var(eta)/N \\(f_4(x)\\)的分布函数为\\(F_4(x)=\\frac{e^{-x}-1}{e^{-1}-1}\\) # I4 u &lt;- runif(N) x &lt;- -log((exp(-1)-1)*u+1) eta &lt;- (1-exp(-1))/(1+x^2) I4 &lt;- mean(eta);I4 #&gt; [1] 0.5263397 var4 &lt;- var(eta)/N # I5 u &lt;- runif(N) x &lt;- tan(pi*u/4) eta &lt;- pi*exp(-x)/4 I5 &lt;- mean(eta);I5 #&gt; [1] 0.5229833 var5 &lt;- var(eta)/N df &lt;- data.frame( `f1` = c(I1,var1), `f2` = c(I2,var2), `f3` = c(I3,var3), `f4` = c(I4,var4), `f5` = c(I5,var5) ) rownames(df) &lt;- c(&quot;I估计&quot;,&quot;I的方差估计&quot;) knitr::kable(df,row.names = TRUE,digits = 9) f1 f2 f3 f4 f5 I估计 0.525298867 0.52609148 0.518276067 0.526339670 0.522983320 I的方差估计 0.000005979 0.00000094 0.000001934 0.000000919 0.000001987 \\(f_1\\)的方差明显大于其他，是因为形状匹配度不及其他，另外2和4以及3和5的方法类似，方差也相差无几。 N &lt;- 1000 m &lt;- 10 u &lt;- matrix(0.1*runif(m*N),m,N) s &lt;- seq(0,1,length.out = m+1)[-(m+1)] u &lt;- u+s x &lt;- exp(-u)/(1+u^2)/m eta &lt;- apply(x,1,mean) I6 &lt;- sum(eta);I6 #&gt; [1] 0.5248444 var6 &lt;- sum(apply(x,1,var))/m/N;var6 #&gt; [1] 6.110511e-09 var1/var6 # 跟未分层的平均值法比较 #&gt; [1] 978.4227 按照例13.2的方法，但是有一点问题就是，每层样本数\\(N_j=1\\)，那每层的方差都没法计算，导致总方差也没法计算呀… N &lt;- 10000 u &lt;- runif(N) eta &lt;- ((1:N)-1+u)/N eta &lt;- map_dbl(eta,fun.h) I7 &lt;- mean(eta);I7 #&gt; [1] 0.5247968 "],["sim-varreduct.html", "10 方差缩减技术 10.1 习题", " 10 方差缩减技术 10.1 习题 习题1 先利用平均值法求解积分： N &lt;- 10000 u &lt;- matrix(runif(N*2),N,2) eta &lt;- exp((u[,1]+u[,2])^2) I1 &lt;- mean(eta);I1 #&gt; [1] 4.878306 var1 &lt;- var(eta)/N;var1 #&gt; [1] 0.003524155 利用对立变量法改进 ： N &lt;- 10000 u &lt;- matrix(runif(N*2),N,2) v &lt;- 1-u eta &lt;- 0.5*(exp((u[,1]+u[,2])^2)+exp((v[,1]+v[,2])^2)) I2 &lt;- mean(eta);I2 #&gt; [1] 4.929019 var2 &lt;- var(eta)/N;var2 #&gt; [1] 0.001189351 习题2 mu &lt;- 0 Sigma &lt;- 1 N &lt;- 100000 n &lt;- c(5,10,30) b1 &lt;- vector(&quot;double&quot;,length(n)) b2 &lt;- vector(&quot;double&quot;,length(n)) s1 &lt;- vector(&quot;double&quot;,length(n)) s2 &lt;- vector(&quot;double&quot;,length(n)) for(i in seq_along(n)){ x &lt;- matrix(rnorm(N*n[[i]],mu,Sigma),N,n[[i]]) m &lt;- apply(x,1,mean) # 每组样本均值 shat &lt;- apply((x-m)^2,1,sum) shat.1 &lt;- shat/(n[[i]]-1) # 两个方差估计 shat.2 &lt;- shat/n[[i]] b1[[i]] &lt;- mean(shat.1)-Sigma^2 b2[[i]] &lt;- mean(shat.2)-Sigma^2 s1[[i]] &lt;- mean((shat.1-Sigma)^2) s2[[i]] &lt;- mean((shat.2-Sigma)^2) } df &lt;- data.frame( n = n, b1 = b1, b2 = b2, s1 = s1, s2 = s2, d = s1-s2 ) knitr::kable(df) n b1 b2 s1 s2 d 5 -0.0012968 -0.2010375 0.5002920 0.3606019 0.1396901 10 -0.0001247 -0.1001122 0.2228895 0.1905629 0.0323266 30 -0.0004414 -0.0337600 0.0688494 0.0654755 0.0033739 1是无偏估计，2是有偏估计。有由可以看出，估计1点偏差要更小但均方误差要更大，所有指标随着样本数的增大都逐渐下降。 "],["sim-des.html", "11 随机服务系统模拟 11.1 笔记 11.2 习题", " 11 随机服务系统模拟 11.1 笔记 这里主要学习一下R包simmer的一些用法，主要参考该包的文档. 11.1.1 基本用法 先实例化一个新的模拟环境 library(simmer) #&gt; #&gt; Attaching package: &#39;simmer&#39; #&gt; The following object is masked from &#39;package:GGally&#39;: #&gt; #&gt; wrap #&gt; The following object is masked from &#39;package:dplyr&#39;: #&gt; #&gt; select #&gt; The following object is masked from &#39;package:tidyr&#39;: #&gt; #&gt; separate set.seed(42) env &lt;- simmer(&quot;SuperDuperSim&quot;) env #&gt; simmer environment: SuperDuperSim | now: 0 | next: #&gt; { Monitor: in memory } 建立一个简单的轨迹：模拟患者问诊。什么是轨迹呢，实际上就是对每名对象的服务过程。 ## trajectory初始化一个轨迹对象 patient &lt;- trajectory(&quot;patients&#39; path&quot;) %&gt;% ## 添加一个护士事件 ## 抓住一个护士资源 seize(&quot;nurse&quot;, 1) %&gt;% ## 服务时间分布 timeout(function() rnorm(1, 15)) %&gt;% ## 释放一个护士资源 release(&quot;nurse&quot;, 1) %&gt;% ## 添加一个医生事件 seize(&quot;doctor&quot;, 1) %&gt;% timeout(function() rnorm(1, 20)) %&gt;% release(&quot;doctor&quot;, 1) %&gt;% ## 添加一个管理员事件 seize(&quot;administration&quot;, 1) %&gt;% timeout(function() rnorm(1, 5)) %&gt;% release(&quot;administration&quot;, 1) 往模拟系统添加资源： env %&gt;% ## 1个护士 add_resource(&quot;nurse&quot;, 1) %&gt;% ## 2个医生 add_resource(&quot;doctor&quot;, 2) %&gt;% ## 1个管理员 add_resource(&quot;administration&quot;, 1) %&gt;% ## 患者到达的时间间隔分布 add_generator(&quot;patient&quot;, patient, function() rnorm(1, 10, 2)) #&gt; simmer environment: SuperDuperSim | now: 0 | next: 0 #&gt; { Monitor: in memory } #&gt; { Resource: nurse | monitored: TRUE | server status: 0(1) | queue status: 0(Inf) } #&gt; { Resource: doctor | monitored: TRUE | server status: 0(2) | queue status: 0(Inf) } #&gt; { Resource: administration | monitored: TRUE | server status: 0(1) | queue status: 0(Inf) } #&gt; { Source: patient | monitored: 1 | n_generated: 0 } 测试运行我们的模拟系统： env %&gt;% ## 运行80个时间单位 run(80) %&gt;% ## 验证当前的模拟时间点 now() #&gt; [1] 80 ## 未来三个事件到来的时刻 env %&gt;% peek(3) #&gt; [1] 80.69540 81.62105 81.62105 也可以指定运行多少个事件： env %&gt;% stepn() %&gt;% # 1 step print() %&gt;% stepn(3) # 3 steps #&gt; simmer environment: SuperDuperSim | now: 80.6953988949657 | next: 80.6953988949657 #&gt; { Monitor: in memory } #&gt; { Resource: nurse | monitored: TRUE | server status: 1(1) | queue status: 1(Inf) } #&gt; { Resource: doctor | monitored: TRUE | server status: 1(2) | queue status: 0(Inf) } #&gt; { Resource: administration | monitored: TRUE | server status: 0(1) | queue status: 0(Inf) } #&gt; { Source: patient | monitored: 1 | n_generated: 7 } #&gt; simmer environment: SuperDuperSim | now: 81.6210531397386 | next: 81.6210531397386 #&gt; { Monitor: in memory } #&gt; { Resource: nurse | monitored: TRUE | server status: 1(1) | queue status: 2(Inf) } #&gt; { Resource: doctor | monitored: TRUE | server status: 1(2) | queue status: 0(Inf) } #&gt; { Resource: administration | monitored: TRUE | server status: 0(1) | queue status: 0(Inf) } #&gt; { Source: patient | monitored: 1 | n_generated: 7 } 也可以看看系统的最终状态： env %&gt;% peek(Inf, verbose=TRUE) #&gt; time process #&gt; 1 81.62105 patient #&gt; 2 86.74154 patient4 #&gt; 3 89.36934 patient3 接下来说明一下如何重置系统。一个方法是执行一个比较长的时间单位（比较一下上面的最终状态时间）： env %&gt;% run(120) %&gt;% now() #&gt; [1] 120 当然，也可以利用reset()函数： env %&gt;% reset() %&gt;% run(80) %&gt;% now() #&gt; [1] 80 可以利用R基本函数多次复制同一个系统，比如复制100次同一个系统： envs &lt;- lapply(1:100, function(i) { simmer(&quot;SuperDuperSim&quot;) %&gt;% add_resource(&quot;nurse&quot;, 1) %&gt;% add_resource(&quot;doctor&quot;, 2) %&gt;% add_resource(&quot;administration&quot;, 1) %&gt;% add_generator(&quot;patient&quot;, patient, function() rnorm(1, 10, 2)) %&gt;% run(80) }) length((envs)) #&gt; [1] 100 下面这个方法可能会更好。如果单个复制品运行起来花费比较大，可以直接并行地运行他们。这里利用的是parallel包。 library(parallel) envs &lt;- mclapply(1:100, function(i) { simmer(&quot;SuperDuperSim&quot;) %&gt;% add_resource(&quot;nurse&quot;, 1) %&gt;% add_resource(&quot;doctor&quot;, 2) %&gt;% add_resource(&quot;administration&quot;, 1) %&gt;% add_generator(&quot;patient&quot;, patient, function() rnorm(1, 10, 2)) %&gt;% run(80) %&gt;% wrap() }) 如何获取各种属性： ## 返回到达数量 envs[[1]] %&gt;% get_n_generated(&quot;patient&quot;) #&gt; [1] 9 ## 获取排队人数 envs[[1]] %&gt;% get_queue_count(&quot;doctor&quot;) #&gt; [1] 0 ## 获取排队容量 envs[[1]] %&gt;% get_queue_size(&quot;doctor&quot;) #&gt; [1] Inf ## 获取监控的资源状态 envs %&gt;% get_mon_resources() %&gt;% head() #&gt; resource time server queue capacity queue_size system limit replication #&gt; 1 nurse 8.680399 1 0 1 Inf 1 Inf 1 #&gt; 2 nurse 18.065588 1 1 1 Inf 2 Inf 1 #&gt; 3 nurse 22.798471 1 0 1 Inf 1 Inf 1 #&gt; 4 doctor 22.798471 1 0 2 Inf 1 Inf 1 #&gt; 5 nurse 27.874898 1 1 1 Inf 2 Inf 1 #&gt; 6 nurse 36.522502 1 0 1 Inf 1 Inf 1 ## 获取监控的到达状态 envs %&gt;% get_mon_arrivals() %&gt;% head() #&gt; name start_time end_time activity_time finished replication #&gt; 1 patient0 8.680399 47.82654 39.14614 TRUE 1 #&gt; 2 patient1 18.065588 62.27708 39.47860 TRUE 1 #&gt; 3 patient2 27.874898 77.13731 40.61481 TRUE 1 #&gt; 4 patient0 7.639828 47.39533 39.75551 TRUE 2 #&gt; 5 patient1 17.311110 65.52527 41.36600 TRUE 2 #&gt; 6 patient2 30.961440 76.90152 40.23089 TRUE 2 11.1.2 更进一步的轨迹使用方法 前面谈到了，对于轨迹的活动，常用的有seize,timeout,release，但此外还有很多更高级的方法，全部方法如下: methods(class=&quot;trajectory&quot;) #&gt; [1] [ [[ [[&lt;- #&gt; [4] [&lt;- activate batch #&gt; [7] branch clone deactivate #&gt; [10] get_n_activities handle_unfinished join #&gt; [13] leave length log_ #&gt; [16] print release release_all #&gt; [19] release_selected release_selected_all renege_abort #&gt; [22] renege_if renege_in rep #&gt; [25] rollback seize seize_selected #&gt; [28] select send separate #&gt; [31] set_attribute set_capacity set_capacity_selected #&gt; [34] set_global set_prioritization set_queue_size #&gt; [37] set_queue_size_selected set_source set_trajectory #&gt; [40] stop_if synchronize timeout #&gt; [43] timeout_from_attribute trap untrap #&gt; [46] wait #&gt; see &#39;?methods&#39; for accessing help and source code 许多的活动方法都可以接受动态参数，也即接受一个函数（可以很复杂，包含很多交互），特别提一下timeout，正如我们前面使用了函数作为参数timeout(function() rnorm(1, 15))，但若只使用timeout(rnorm(1, 15))，只会生成一个随机数然后是静态参数。 轨迹可以跟模拟环境进行很多焦糊，常见的就是获取模拟环境的很多属性。一个需要注意的地方是，我们最好有这样的习惯：首先实例化模拟环境，而不是创建轨迹或者其他什么的，避免难以察觉的错误。 接下来是一下对轨迹联合以及取子集的操作。 join()函数可以联合拼接轨迹，可以利用[、[[、head()、tail()等运算符或者函数取轨迹的子集。 11.2 习题 习题1 将时间单位看作小时。 library(simmer) set.seed(1024) mu &lt;- 1.0 lambda &lt;- 0.8 fun_rexp_mu &lt;- function() rexp(1, mu) fun_rexp_lambda &lt;- function() rexp(1, lambda) bank &lt;- simmer(&quot;bank&quot;) customer &lt;- trajectory(&quot;customer&quot;) %&gt;% seize(&quot;counter&quot;,1) %&gt;% timeout(fun_rexp_mu) %&gt;% release(&quot;counter&quot;) bank %&gt;% add_resource(&quot;counter&quot;,1) %&gt;% # 从8点到17点，24小时后循环 add_generator(&quot;customer&quot;,customer,from_to(8,17,fun_rexp_lambda,every = 24)) #&gt; simmer environment: bank | now: 0 | next: 0 #&gt; { Monitor: in memory } #&gt; { Resource: counter | monitored: TRUE | server status: 0(1) | queue status: 0(Inf) } #&gt; { Source: customer | monitored: 1 | n_generated: 0 } # 2天内的服务情况 bank %&gt;% run(48) %&gt;% get_mon_arrivals() #&gt; name start_time end_time activity_time finished replication #&gt; 1 customer0 8.00000 9.217335 1.2173351 TRUE 1 #&gt; 2 customer1 10.03479 10.534241 0.4994537 TRUE 1 #&gt; 3 customer2 14.79583 15.765146 0.9693123 TRUE 1 #&gt; 4 customer3 16.90828 17.084277 0.1759946 TRUE 1 #&gt; 5 customer4 32.00000 32.243604 0.2436042 TRUE 1 #&gt; 6 customer5 36.49778 36.861577 0.3637970 TRUE 1 #&gt; 7 customer6 36.65448 37.902313 1.0407360 TRUE 1 #&gt; 8 customer7 37.54700 38.997167 1.0948535 TRUE 1 #&gt; 9 customer8 38.64765 41.565584 2.5684179 TRUE 1 #&gt; 10 customer9 39.01735 42.006504 0.4409200 TRUE 1 #&gt; 11 customer10 39.76817 43.491433 1.4849281 TRUE 1 不妨假设： \\[ \\lambda(t)= \\begin{cases} 2 &amp; 0\\le t&lt;10\\\\ 1.9 &amp; 10\\le t&lt;20\\\\ \\cdots \\\\ 1.1 &amp; t\\ge 90\\\\ \\end{cases} \\] library(simmer) set.seed(1024) mu &lt;- 1.0 bank &lt;- simmer(&quot;bank&quot;) fun_rexp_mu &lt;- function() rexp(1, mu) fun_rexp_lambda &lt;- function(){ t &lt;- now(bank) lambda &lt;- ifelse(t&lt;90,2-floor(t/10)*0.1,1.1) rexp(1,lambda) } customer &lt;- trajectory(&quot;customer&quot;) %&gt;% seize(&quot;counter&quot;,1) %&gt;% timeout(fun_rexp_mu) %&gt;% release(&quot;counter&quot;,1) bank %&gt;% add_resource(&quot;counter&quot;,1) %&gt;% add_generator(&quot;customer&quot;,customer,fun_rexp_lambda) #&gt; simmer environment: bank | now: 0 | next: 0 #&gt; { Monitor: in memory } #&gt; { Resource: counter | monitored: TRUE | server status: 0(1) | queue status: 0(Inf) } #&gt; { Source: customer | monitored: 1 | n_generated: 0 } # 测试 bank %&gt;% run(10) #&gt; simmer environment: bank | now: 10 | next: 10.3397909260835 #&gt; { Monitor: in memory } #&gt; { Resource: counter | monitored: TRUE | server status: 1(1) | queue status: 9(Inf) } #&gt; { Source: customer | monitored: 1 | n_generated: 19 } bank %&gt;% get_queue_count(&quot;counter&quot;) #&gt; [1] 9 bank %&gt;% get_mon_arrivals() #&gt; name start_time end_time activity_time finished replication #&gt; 1 customer0 0.8139149 4.622752 3.8088375 TRUE 1 #&gt; 2 customer1 1.4225824 4.866357 0.2436042 TRUE 1 #&gt; 3 customer2 1.6723093 4.991716 0.1253592 TRUE 1 #&gt; 4 customer3 2.5172887 5.705730 0.7140139 TRUE 1 #&gt; 5 customer4 3.0019448 6.800583 1.0948535 TRUE 1 #&gt; 6 customer5 3.0998351 7.401239 0.6006554 TRUE 1 #&gt; 7 customer6 3.1878324 8.659349 1.2581106 TRUE 1 #&gt; 8 customer7 4.9869445 9.805886 1.1465369 TRUE 1 我们用上leave、renege_in等函数： # 输入： # L,P.1: 队伍长度大于L，顾客有一定概率P.1离开 # T,P.2: 等待时间超过T，顾客有一定概率P.2离开 # T1: 系统运行时间 # mu,lambda: 服务系统参数 # 输出：离开的顾客人数 simmer.1.3 &lt;- function(L=3,P.1=0.8,T=11,P.2=0.8,T1=200,mu=1.0,lambda=0.9) { library(simmer) fun_rexp_mu &lt;- function() rexp(1, mu) fun_rexp_lambda &lt;- function() rexp(1, lambda) bank &lt;- simmer(&quot;bank&quot;,log_level = 0) tra1 &lt;- trajectory() %&gt;% seize(&quot;counter&quot;,1) %&gt;% renege_abort() %&gt;% log_(&quot;I&#39;m being attended&quot;,level = 1) %&gt;% timeout(fun_rexp_mu) %&gt;% release(&quot;counter&quot;,1) %&gt;% log_(&quot;finished&quot;,level = 1) customer &lt;- trajectory(&quot;customer&quot;) %&gt;% log_(&quot;here I am&quot;,level = 1) %&gt;% log_(function(){ paste(&quot;the length of queue is&quot;,get_queue_count(bank,&quot;counter&quot;)) },level = 1) %&gt;% # 一定概率离开 log_(&quot;I am leaving...&quot;,level = 1) %&gt;% leave(function(){ l &lt;- get_queue_count(bank, &quot;counter&quot;) # 队伍长度 ifelse(l&gt;L,P.1,0) # 若队伍长度大于L以P.1概率离开 }) %&gt;% log_(&quot;It is a joke...&quot;,level = 1) %&gt;% # 等待时间一定概率P.2离开 renege_in( T, out = trajectory() %&gt;% log_(&quot;lost my patience. Reneging...&quot;,level = 1) %&gt;% leave(P.2) %&gt;% log_(&quot;It is a joke...&quot;,level = 1) %&gt;% join(tra1) ) %&gt;% join(tra1) bank %&gt;% add_resource(&quot;counter&quot;, 1) %&gt;% add_generator(&quot;customer&quot;, customer, fun_rexp_lambda) %&gt;% run(T1) %&gt;% invisible %&gt;% get_mon_arrivals() %&gt;% dplyr::summarise(leave_count = sum(!finished)) } simmer.1.3() #&gt; leave_count #&gt; 1 14 以默认的参数，重复运行多次求均值： N &lt;- 1000 out &lt;- vector(&quot;integer&quot;,N) for (i in 1:N) { s &lt;- simmer.1.3() out[[i]] &lt;- s$leave_count } mean(out) #&gt; [1] 20.977 习题2 没想明白，继续想想…… "]]
