[["index.html", "统计计算 背景", " 统计计算 Huang 2021-08-03 背景 开始学习《统计计算》，主要参考李东风老师的网页教材，链接：https://www.math.pku.edu.cn/teachers/lidf/docs/statcomp/html/_statcompbook/index.html 。 2021-7-6 "],["intro-error.html", "1 误差 1.1 习题", " 1 误差 library(purrr) 1.1 习题 习题1 编程计算机器的值。 解： R语言中可以使用 .Machine$double.eps #&gt; [1] 2.22e-16 .Machine下面列有很多误差相关的机器参数，有需要的可以查阅这里。 习题2 设某正数\\(a\\)四舍五入后保留了\\(p\\)位有效数字，表示成\\(a^* = (0.a_1a_2\\cdots a_p)_{10}\\times10^m(a_1\\ne0)\\)。 估计其绝对误差和相对误差的范围， 并分析误差与有效数字位数\\(p\\)的关系。 解： 容易知道，\\(m\\ge p\\)。先通过一个例子直观理解一下，不妨取\\(a=12546\\)，当取\\(p=3\\)，有\\(a^*=0.125\\times 10^5=12500\\)，当取\\(p=4\\)，有\\(a^*=0.1255\\times 10^5=12550\\)。 所以可以得到，\\(m\\)实际上是正数\\(a\\)的位数，而\\(p\\)则是要保留的有效数字的位数。 其绝对误差： \\[ \\Delta = a-a^*\\le 0.5\\times10^{m-p} \\] 利用\\(a\\ge10^m\\)，其相对误差： \\[ \\delta = \\frac{\\Delta}{a} \\le\\frac{0.5\\times10^{m-p}}{10^m}=0.5\\times10^{-p} \\] 习题3 解： 先定义通项： myfun &lt;- function(n) { (-1)^(n+1)/n } n &lt;- 10^6 S &lt;- 0 for (i in 1:n) { S &lt;- S+myfun(i) } abs(S-log(2)) #&gt; [1] 5e-07 S &lt;- 0 for (i in 1:n) { S &lt;- S+myfun(n+1-i) } abs(S-log(2)) #&gt; [1] 5e-07 S &lt;- 0 l &lt;- vector(&quot;double&quot;,n/2) for (i in 1:(n/2)) { l[[i]] &lt;- myfun(2*i-1)+myfun(2*i) } for (i in l) { S &lt;- S+i } abs(S-log(2)) #&gt; [1] 5e-07 l &lt;- vector(&quot;double&quot;,n/2) for (i in 1:(n/2)) { l[[i]] &lt;- 1/(2*n*2*(n-1)) } for (i in l) { S &lt;- S+i } abs(S-log(2)) #&gt; [1] 3.75e-07 第4种方法精度更高。 习题4 解： x &lt;- 1:4 myfun1 &lt;- function(x, k=10) { S &lt;- 1 for (i in 1:k) { m &lt;- (-x)^i/factorial(i) S &lt;- S+m } S } myfun2 &lt;- function(x, k=10) { S &lt;- 1 for (i in 1:k) { m &lt;- x^i/factorial(i) S &lt;- S+m } 1/S } s1 &lt;- map_dbl(x,myfun1) s2 &lt;- map_dbl(x,myfun2) s &lt;- exp(-x) df &lt;- data.frame(x,s1=abs(s1-s),s2=abs(s2-s)) knitr::kable(df) x s1 s2 1 0.000 0 2 0.000 0 3 0.004 0 4 0.078 0 方法1的误差太大了，不妨增大\\(k\\)值： s1 &lt;- map_dbl(x,myfun1,k=100) s2 &lt;- map_dbl(x,myfun2) s &lt;- exp(-x) df &lt;- data.frame(x,s1=abs(s1-s),s2=abs(s2-s)) knitr::kable(df) x s1 s2 1 0 0 2 0 0 3 0 0 4 0 0 误差瞬间下去，说明方法1的收敛比较慢。以\\(x=4\\)为例，探究两个方法的收敛速度： x &lt;- 4 k &lt;- 1:50 s1 &lt;- map_dbl(k,myfun1,x=x) s2 &lt;- map_dbl(k,myfun2,x=x) s &lt;- exp(-x) opar &lt;- par(no.readonly = TRUE) plot(k,abs(s1-s),&quot;l&quot;,ylab=&quot;&quot;) lines(k,abs(s2-s),lty=2,col=&quot;red&quot;) title(ylab=&quot;绝对误差&quot;) legend(&quot;topright&quot;,c(&quot;公式（1）&quot;,&quot;公式（2）&quot;),lty=c(1,2),col=c(&quot;black&quot;,&quot;red&quot;)) par(opar) 可以看到公式（1）的收敛速度一开始是很慢的。 习题5 解： 载入数据： x &lt;- c(249, 254, 243, 268, 253, 269, 287, 241, 273, 306303, 280, 260, 256, 278, 344, 304, 283, 310) n &lt;- length(x) 公式1： s1 &lt;- 0 for (i in x) { s1 &lt;- signif(s1+signif(i^2,digits = 6),digits = 6) } s1 &lt;- signif(s1-n*mean(x),digits = 6) s1 &lt;- signif(s1/(n-1),digits = 6) 公式2： s2 &lt;- 0 m &lt;- mean(x) for (i in x) { s2 &lt;- signif(s2+signif((i-m)^2,digits = 6),digits = 6) } s2 &lt;- signif(s2/(n-1),digits = 6) 比较： df &lt;- data.frame(`函数直接计算`=var(x),`公式1`=s1,`公式2`=s2) knitr::kable(df) 函数直接计算 公式1 公式2 5.2e+09 5.52e+09 5.2e+09 公式2比公式1更精确，公式1先计算平方求和，值太大，保留6位有效数字之后损失较多。 习题6 解： "],["intro-summary.html", "2 概括统计量 2.1 习题", " 2 概括统计量 library(tidyverse) #&gt; -- Attaching packages ----- tidyverse 1.3.0 -- #&gt;  ggplot2 3.3.2  dplyr 1.0.2 #&gt;  tibble 3.0.3  stringr 1.4.0 #&gt;  tidyr 1.1.1  forcats 0.5.0 #&gt;  readr 1.3.1 #&gt; -- Conflicts -------- tidyverse_conflicts() -- #&gt; x dplyr::filter() masks stats::filter() #&gt; x dplyr::lag() masks stats::lag() 2.1 习题 习题1 解： skewness &lt;- function(x) { n &lt;- length(x) y &lt;- (x-mean(x))/sd(x) phi &lt;- n*sum(y^3)/(n-1)/(n-2) phi } 测试： x &lt;- c(8.75, 10.37, 8.33, 13.19, 10.66, 8.36, 10.97, 11.48, 11.15, 9.39) skewness(x) #&gt; [1] 0.3516643 习题2 解： 定义函数： quantile_est &lt;- function(x, p) { p &lt;- as.double(p) if(p&lt;0 | p&gt;1) stop(&quot;The &#39;p&#39; is out of [0,1].&quot;) else if(p==0) xp &lt;- min(x) else if(p==1) xp &lt;- max(x) else{ n &lt;- length(x) t &lt;- table(x) r &lt;- as.double(names(t)) i &lt;- floor(p*(n+1/3)+1/3) # xq左侧的x(i) j &lt;- i+t[names(t)==r[i]] # xq右侧x(j) k &lt;- (j-i)/(n+1/3)/(r[i+1]-r[i]) xp &lt;- p-(i-1/3)/(n+1/3)+k*r[i] xp &lt;- xp/k } names(xp) &lt;- p xp } 与quantile()以及真实分位数的比较： x &lt;- rnorm(1000) tbl &lt;- tibble(p = seq(0,1,by = 0.1)) tbl[&quot;real&quot;] &lt;- qnorm(tbl$p) tbl[&quot;quantile&quot;] &lt;- quantile(x,tbl$p) tbl[&quot;quantile_est&quot;] &lt;- map_dbl(tbl$p,quantile_est,x=x) tbl %&gt;% ggplot(aes(x=p))+ geom_line(aes(y=real,color=&quot;real&quot;))+ geom_line(aes(y=quantile,color=&quot;quantile&quot;))+ geom_line(aes(y=quantile_est,color=&quot;quantile_est&quot;),linetype=2)+ ylab(&quot;value&quot;) 可以看到，自定义函数跟quantile()函数得到的值重合度非常高，与真实分位数也差别不大。 习题3 解： 3.2.1 证明： \\[ \\bar{x}_n = \\frac1n\\sum_{i=1}^nx_i=\\frac{n-1}n\\times\\frac{\\sum_{i=1}^{n-1}x_i}{n-1}+\\frac{x_n}n=\\frac{n-1}n\\bar{x}_{n-1}+\\frac{x_n}n \\] 3.2.2 证明： \\[ \\begin{align} (n-1)S_n^2 &amp;= \\sum_{i=1}^n(x_i-\\bar x_n)^2\\\\ &amp;= \\sum_{i=1}^n(x_i-\\bar x_{n-1}+\\bar x_{n-1}-\\bar x_n)^2\\\\ &amp;= \\sum_{i=1}^n(x_i-\\bar x_{n-1})^2+2(\\bar x_{n-1}-\\bar x_n)\\sum_{i=1}^n(x_i-\\bar x_{n-1})+\\sum_{i=1}^n(\\bar x_{n-1}-\\bar x_n)^2\\\\ &amp;= (n-2)S_{n-1}^2+(x_n-\\bar x_{n-1})^2-2n(\\bar x_n-\\bar x_{n-1})^2+n(\\bar x_{n-1}-\\bar x_n)^2\\\\ &amp;= (n-2)S_{n-1}^2+(x_n-\\bar x_{n-1})^2-n(\\bar x_n-\\bar x_{n-1})^2\\\\ &amp;= (n-2)S_{n-1}^2+(x_n-\\bar x_{n-1})^2-n(\\frac{x_n}{n}-\\frac{\\bar x_{n-1}}{n})^2\\\\ &amp;= (n-2)S_{n-1}^2+(x_n-\\bar x_{n-1})^2-\\frac1n(x_n-\\bar x_{n-1})^2\\\\ &amp;= (n-2)S_{n-1}^2+\\frac{n-1}n(x_n-\\bar x_{n-1})^2 \\end{align} \\] 从而： \\[ S_n^2 = \\frac{n-2}{n-1}S_{n-1}^2+\\frac{1}n(x_n-\\bar x_{n-1})^2 \\] 习题4 解： 求均值的递推公式一样，直接向量化运算就行. 求协方差的递推算法跟求方差类似： 由于 \\[ \\Sigma_n = \\frac{1}{n-1}\\sum_{i=1}^n(x_i-\\bar x_n)(x_i-\\bar x_n)^T \\] 从而： \\[ \\begin{align} (n-1)\\Sigma_n &amp;= \\sum_{i=1}^n(x_i-\\bar x_n)(x_i-\\bar x_n)^T\\\\ &amp;= \\sum_{i=1}^n(x_i-\\bar x_{n-1}+\\bar x_{n-1}-\\bar x_n)(x_i-\\bar x_{n-1}-\\bar x_{n-1}+\\bar x_n)^T\\\\ &amp;= (n-2)\\Sigma_{n-1}+\\frac{n-1}{n}(x_n-\\bar x_{n-1})(x_n-\\bar x_{n-1})^T \\end{align} \\] 即 \\[ \\Sigma_n = \\frac{n-2}{n-1}\\Sigma_{n-1}+\\frac{1}{n}(x_n-\\bar x_{n-1})(x_n-\\bar x_{n-1})^T \\] "],["intro-graph.html", "3 统计图形 3.1 习题", " 3 统计图形 library(tidyverse) library(GGally) #&gt; Registered S3 method overwritten by &#39;GGally&#39;: #&gt; method from #&gt; +.gg ggplot2 set.seed(1024) 3.1 习题 习题1 解： opar &lt;- par(no.readonly = TRUE) par(mfrow=c(5,3)) par(mar=rep(2,4)) #第一种 n=c(10, 20, 30, 50, 100) for(i in seq_along(n)) { hist(rnorm(n[[i]]),freq = FALSE,main = paste(&quot;n=&quot;,n[[i]],&quot;，标准正态&quot;)) hist(exp(rnorm(n[[i]])),freq = FALSE,main = paste(&quot;n=&quot;,n[[i]],&quot;，对数正态&quot;)) hist(rcauchy(n[[i]]),freq = FALSE,main = paste(&quot;n=&quot;,n[[i]],&quot;，柯西分布&quot;)) } par(opar) 习题2 解： iris %&gt;% ggpairs(aes(color=Species,shape=Species), columns = 1:4, upper = list(continuous = &quot;points&quot;)) "],["rng-uniform.html", "4 均匀分布随机数生成 4.1 习题", " 4 均匀分布随机数生成 set.seed(1024) 4.1 习题 习题1 易证。 习题2 解： 将[0,1]等分为\\(k\\)段，每个端点分别为\\(x_i=i/k,i=0,\\dots,k\\)，考虑左闭右开区间，如果给定点\\(x\\)落在\\(x_i\\le x&lt;x_{i+1}\\)中，有\\(i/k\\le x&lt;(i+1)/k\\)，即\\(i\\le kx &lt;i+1\\)，\\(\\lfloor kx \\rfloor=i\\)，若\\(x&lt;0\\)或\\(x&gt;1\\)报错。 runif.chisq.test &lt;- function(x, k) { y &lt;- rep(0,k) for (i in seq_along(x)) { j &lt;- floor(k*x[[i]]) # 第j段 if(x[[i]]==1){ y[[k]] &lt;- y[[k]]+1 }else if(j&lt;0 | j&gt;=k){ stop(&quot;there is value of x out of [0,1]&quot;) }else{ y[[j+1]] &lt;- y[[j+1]]+1 } } chisq.test(y) } 测试一下： x &lt;- runif(1000) k &lt;- 10 runif.chisq.test(x,k) #&gt; #&gt; Chi-squared test for given probabilities #&gt; #&gt; data: y #&gt; X-squared = 3.06, df = 9, p-value = 0.9619 通过检验。 x &lt;- rnorm(1000) x &lt;- x[x&gt;=0&amp;x&lt;=1] k &lt;- 10 runif.chisq.test(x,k) #&gt; #&gt; Chi-squared test for given probabilities #&gt; #&gt; data: y #&gt; X-squared = 20.047, df = 9, p-value = 0.01763 显著性水平0.05下拒绝原假设。 习题3 解： 类似地，这里对输入数据的最小值与最大值之间等分\\(k\\)段，每个端点分别为\\(x_i=i/k,i=0,\\dots,k\\)，考虑左闭右开区间，如果给定点\\(x\\)落在\\(x_i\\le x&lt;x_{i+1}\\)中，有\\(i/k\\le x&lt;(i+1)/k\\)，即\\(i\\le kx &lt;i+1\\)，\\(\\lfloor kx \\rfloor=i\\)。 # F为分布函数 random.chisq.test &lt;- function(x, k, F) { library(purrr) xmin &lt;- min(x) xmax &lt;- max(x) d &lt;- xmax-xmin j &lt;- floor(k*(x-xmin)/d) y &lt;- rep(0,k+2) for (i in seq_along(x)) { if(x[[i]]==max(x)){ y[[k+1]] &lt;- y[[k+1]]+1 }else{ y[[j[[i]]+2]] &lt;- y[[j[[i]]+2]]+1 } } p &lt;- seq(xmin,xmax,length.out = k+1) %&gt;% map_dbl(F) p &lt;- c(p[[1]],diff(p),1-p[[k+1]]) chisq.test(y,p = p) } 测试： x &lt;- rnorm(1000) k &lt;- 10 random.chisq.test(x,k,pnorm) #&gt; Warning in chisq.test(y, p = p): Chi-squared approximation may be incorrect #&gt; #&gt; Chi-squared test for given probabilities #&gt; #&gt; data: y #&gt; X-squared = 8.422, df = 11, p-value = 0.6751 x &lt;- runif(1000) k &lt;- 10 random.chisq.test(x,k,pnorm) #&gt; #&gt; Chi-squared test for given probabilities #&gt; #&gt; data: y #&gt; X-squared = 2044.9, df = 11, p-value &lt; 2.2e-16 通过测试。 习题4 解： 这个应该是下一节的内容，不过无所谓啦。先得到它的分布函数为 \\[ F(x) = \\frac12x+\\frac12x^2,\\quad0\\le x\\le1 \\] 1、逆变换法： 先求\\(F^{-1}\\)为： \\[ F^{-1}(u) = -\\frac12+\\sqrt{2u+\\frac14} \\] 从而定义函数： rng.x1 &lt;- function(n) { -0.5+sqrt(2*runif(n)+0.25) } 测试： n &lt;- 1000 x &lt;- rng.x1(n) hist(x,freq = FALSE) y &lt;- seq(0,1,0.01) z &lt;- 0.5+y lines(y,z,col=&quot;red&quot;) 基本吻合。 2、舍选法 就是拒绝采样啦，取提议分布为均匀分布\\(U[0,1]\\)，则\\(c=1.5\\). rng.x2 &lt;- function(n) { x &lt;- runif(n) y &lt;- runif(n,0,1.5) s &lt;- x[y&lt;=0.5+x] list(samples = s, eff = length(s)/n) } 测试： n &lt;- 1000 x &lt;- rng.x2(n) hist(x$samples,freq = FALSE) y &lt;- seq(0,1,0.01) z &lt;- 0.5+y lines(y,z,col=&quot;red&quot;) 基本吻合。看一下效率： x$eff #&gt; [1] 0.669 理论上的效率为\\(2/3\\)。 3、复合法 将梯形面积分解为一个矩形跟一个三角形，两者面积都是0.5。 rng.x3 &lt;- function(n) { i &lt;- runif(n) x &lt;- runif(n) # 小于等于0.5保持值，大于0.5开平方 x[i&gt;0.5] &lt;- sqrt(x[i&gt;0.5]) x } 测试： n &lt;- 1000 x &lt;- rng.x3(n) hist(x,freq = FALSE) y &lt;- seq(0,1,0.01) z &lt;- 0.5+y lines(y,z,col=&quot;red&quot;) 比较算法的效率？除了舍选法会拒绝点之外，其余两者算法都是全部接受点的。看一下函数的运行时间吧，虽然这个比较粗糙，因为跟算法编码的设计有关，不一定是算法本身的问题： n &lt;- 10000000 t1.1 &lt;- proc.time() x &lt;- rng.x1(n) t1.2 &lt;- proc.time() t1 &lt;- t1.2-t1.1 t2.1 &lt;- proc.time() x &lt;- rng.x2(n) t2.2 &lt;- proc.time() t2 &lt;- t2.2-t2.1 t3.1 &lt;- proc.time() x &lt;- rng.x3(n) t3.2 &lt;- proc.time() t3 &lt;- t3.2-t3.1 df &lt;- data.frame(`逆变换法`=t1[3][[1]],`舍选法`=t2[3][[1]],`复合法`=t3[3][[1]]) knitr::kable(df) 逆变换法 舍选法 复合法 0.52 1.06 1.1 总的来说，逆变换法要更好点，舍选法要稍差点。 "]]
